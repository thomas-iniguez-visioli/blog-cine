<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Fast And Furious</title>
      <link href="/blog-cine/2025/Fast-And-Furious/"/>
      <url>/blog-cine/2025/Fast-And-Furious/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>présentation</title>
      <link href="/blog-cine/2025/hello-world/"/>
      <url>/blog-cine/2025/hello-world/</url>
      
        <content type="html"><![CDATA[<p> ce blog a été fait pour un concours d’une semaine </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Interstellar</title>
      <link href="/blog-cine/2025/Interstellar/"/>
      <url>/blog-cine/2025/Interstellar/</url>
      
        <content type="html"><![CDATA[<p>meilleur film au monde y’a pas besoin de parler plus.J’aimerais pas etre aveugle </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Les Fausses blondes infiltrées</title>
      <link href="/blog-cine/2025/Les-Fausses-blondes-infiltrees/"/>
      <url>/blog-cine/2025/Les-Fausses-blondes-infiltrees/</url>
      
        <content type="html"><![CDATA[<p>Obligé de rigoler aprés avoir vue ce film audacieux avec des blagues subtiles et bien amenées.A regarder en famille c’est un classique dans le genre de la comédie </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transformers</title>
      <link href="/blog-cine/2025/Transformers/"/>
      <url>/blog-cine/2025/Transformers/</url>
      
        <content type="html"><![CDATA[<p>Transformers c’est un reve d’enfant qu’on voit etre animé c’est comme des jouets qui se transfomre en super robots pour se taper dessus en plus y’a Megan fox dedans donc fonce.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spiderman</title>
      <link href="/blog-cine/2025/Spiderman/"/>
      <url>/blog-cine/2025/Spiderman/</url>
      
        <content type="html"><![CDATA[<p>ce film c’est un classique , a connaitre absolument sinon ta vie est ratée meme une personne qui a l’arachnophobie kifferait Spiderman. On a deja tous réve de se faire piquer par une araignée mais au lieu de ça on a eu 38 piqures contre le covid.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Massacre à la tronçonneuse</title>
      <link href="/blog-cine/2025/Massacre-a-la-tronconneuse/"/>
      <url>/blog-cine/2025/Massacre-a-la-tronconneuse/</url>
      
        <content type="html"><![CDATA[<p>si vous avez aimé vendredi 13 vous etes au bon endroit , y’a pas de blabla le tueur attaque direct.Par contre pour la première fois la meuf qu’on suit est moche par rapport aux autres films d’horreur je crois que c’est elle le massacre.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iron man</title>
      <link href="/blog-cine/2025/iron-man/"/>
      <url>/blog-cine/2025/iron-man/</url>
      
        <content type="html"><![CDATA[<p>Il n’y a rien de vrai qu’un film d’iron man depuis sa mort je regarde ses anciens films. C’est une saga révolutionnaire , c’est robocop mais 100x mieux</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pacific rim</title>
      <link href="/blog-cine/2025/pacific-rim/"/>
      <url>/blog-cine/2025/pacific-rim/</url>
      
        <content type="html"><![CDATA[<p>transformers a tellement percé qu’on en fait des copies , toujours copié mais jamais égalé bref sortez nous un film Transformers.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ready player one</title>
      <link href="/blog-cine/2025/ready-player-one/"/>
      <url>/blog-cine/2025/ready-player-one/</url>
      
        <content type="html"><![CDATA[<p>de base je voulais voir squid game je sais pas comment j’ai attéri ici</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>star wars la menace fantome</title>
      <link href="/blog-cine/2025/star-wars-la-menace-fantome/"/>
      <url>/blog-cine/2025/star-wars-la-menace-fantome/</url>
      
        <content type="html"><![CDATA[<p>premier film d’une série a succès de 9 film</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/blog-cine/about/index.html"/>
      <url>/blog-cine/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog-cine/hexo-admin-ehc-images.json"/>
      <url>/blog-cine/hexo-admin-ehc-images.json</url>
      
        <content type="html"><![CDATA[[{"name":"DASHENG-900x700-1.png","date":1518959551960},{"name":"DASHENG-900x700-2.png","date":1518959599098},{"name":"DASHENG-900x700-3.png","date":1518959609913},{"name":"DASHENG-900x700-4.png","date":1518959618105}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog-cine/search.js"/>
      <url>/blog-cine/search.js</url>
      
        <content type="html"><![CDATA[// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)// Copyright (C) 2015 // Joseph Pan <http://github.com/wzpan>// Shuhao Mao <http://github.com/maoshuhao>// This library is free software; you can redistribute it and/or modify// it under the terms of the GNU Lesser General Public License as// published by the Free Software Foundation; either version 2.1 of the// License, or (at your option) any later version.// // This library is distributed in the hope that it will be useful, but// WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU// Lesser General Public License for more details.// // You should have received a copy of the GNU Lesser General Public// License along with this library; if not, write to the Free Software// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA// 02110-1301 USA// var searchFunc = function(path, search_id, content_id) {    'use strict';    $.ajax({        url: path,        dataType: "xml",        success: function( xmlResponse ) {            // get the contents from search data            var datas = $( "entry", xmlResponse ).map(function() {                return {                    title: $( "title", this ).text(),                    content: $("content",this).text(),                    url: $( "url" , this).text()                };            }).get();            var $input = document.getElementById(search_id);if (!$input) return;            var $resultContent = document.getElementById(content_id);            if ($("#local-search-input").length > 0) {                $input.addEventListener('input', function () {                    var str = '<ul class=\"search-result-list\">';                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);                    $resultContent.innerHTML = "";                    if (this.value.trim().length <= 0) {                        return;                    }                    // perform local searching                    datas.forEach(function (data) {                        var isMatch = true;                        var content_index = [];                        if (!data.title || data.title.trim() === '') {                            data.title = "Untitled";                        }                        var data_title = data.title.trim().toLowerCase();                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();                        var data_url = data.url;                        var index_title = -1;                        var index_content = -1;                        var first_occur = -1;                        // only match artiles with not empty contents                        if (data_content !== '') {                            keywords.forEach(function (keyword, i) {                                index_title = data_title.indexOf(keyword);                                index_content = data_content.indexOf(keyword);                                if (index_title < 0 && index_content < 0) {                                    isMatch = false;                                } else {                                    if (index_content < 0) {                                        index_content = 0;                                    }                                    if (i == 0) {                                        first_occur = index_content;                                    }                                    // content_index.push({index_content:index_content, keyword_len:keyword_len});                                }                            });                        } else {                            isMatch = false;                        }                        // show search results                        if (isMatch) {                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";                            var content = data.content.trim().replace(/<[^>]+>/g, "");                            if (first_occur >= 0) {                                // cut out 100 characters                                var start = first_occur - 20;                                var end = first_occur + 80;                                if (start < 0) {                                    start = 0;                                }                                if (start == 0) {                                    end = 100;                                }                                if (end > content.length) {                                    end = content.length;                                }                                var match_content = content.substring(start, end);                                // highlight all keywords                                keywords.forEach(function (keyword) {                                    var regS = new RegExp(keyword, "gi");                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");                                });                                str += "<p class=\"search-result\">" + match_content + "...</p>"                            }                            str += "</li>";                        }                    });                    str += "</ul>";                    $resultContent.innerHTML = str;                });            }        }    });}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog-cine/admin/bundle.css"/>
      <url>/blog-cine/admin/bundle.css</url>
      
        <content type="html"><![CDATA[@font-face {  font-family: 'Open Sans';  font-style: normal;  font-weight: 300;  src: local('Open Sans Light'), local('OpenSans-Light'), url(fonts/OpenSans-Light.ttf);}@font-face {  font-family: 'Open Sans';  font-style: normal;  font-weight: 400;  src: local('Open Sans'), local('OpenSans'), url(fonts/OpenSans-Regular.ttf);}@font-face {  font-family: 'Open Sans';  font-style: normal;  font-weight: 700;  src: local('Open Sans Bold'), local('OpenSans-Bold'), url(fonts/OpenSans-Bold.ttf);}@font-face {  font-family: 'Open Sans';  font-style: italic;  font-weight: 300;  src: local('Open Sans Light Italic'), local('OpenSansLight-Italic'), url(fonts/OpenSans-LightItalic.ttf);}@font-face {  font-family: 'Open Sans';  font-style: italic;  font-weight: 400;  src: local('Open Sans Italic'), local('OpenSans-Italic'), url(fonts/OpenSans-Italic.ttf);}@font-face {  font-family: 'Open Sans';  font-style: italic;  font-weight: 700;  src: local('Open Sans Bold Italic'), local('OpenSans-BoldItalic'), url(fonts/OpenSans-BoldItalic.ttf);}body {  padding: 0;  margin: 0;}.app {  display: flex;  flex-direction: column;  font-family: "Open Sans";  position: absolute;  top: 0;  left: 0;  bottom: 0;  right: 0;}.app_header {  background-color: #0d1626;}.app_header,.app_header a {  color: #eeeeee;}.app_logo {  width: 25px;  vertical-align: middle;  margin: -4px 10px 0;}.app_nav {  list-style: none;  margin: 0 10px;  padding: 0;  display: inline-block;}.app_nav li {  color: #eeeeee;  font-weight: bold;  display: inline-block;  cursor: pointer;}.app_nav li a {  color: #eeeeee;  text-decoration: none;  padding: 10px 20px 7px;  display: inline-block;  border-bottom: 3px solid transparent;}.app_nav li a.active,.app_nav li a:hover {  border-bottom-color: #6eaeff;  color: #6eaeff;}.app_main {  flex: 1;  display: flex;}.posts {  display: flex;  flex: 1;}.posts_display {  flex: 1;}.posts_list {  background-color: #f7faff;  list-style: none;  padding: 0;  margin: 0;  width: 400px;  overflow: auto;}.posts_post {  padding: 15px 20px;  color: #333333;  cursor: pointer;  position: relative;  transition: background-color 0.3s ease;}.posts_post:hover {  background-color: #ecf3ff;}.posts_post--selected {  background-color: #dfebff;}.posts_post--selected:hover {  background-color: #dfebff;}.posts_post--draft {  color: #aaa;  font-style: italic;}.posts_post-date {  position: absolute;  line-height: 1;  color: #999;  bottom: 5px;  right: 5px;  font-size: 10px;}.posts_display {  display: flex;  position: relative;}.posts_content {  overflow: auto;  padding: 30px;}.posts_draft-message {  background-color: #dfebff;  position: absolute;  top: 0;  left: 0;  right: 0;  padding: 5px;  text-align: center;  color: white;  font-style: italic;  font-weight: bold;  opacity: .9;}.icon-link {  opacity: 0;  position: absolute;  padding: 5px 6px;  border-radius: 15px;  cursor: pointer;  font-size: 14px;  line-height: 1;  transition: opacity 0.3s ease, background-color 0.1s ease;}.icon-link:hover {  background-color: white;}.posts_post:hover .icon-link {  opacity: 1;}.posts_edit-link {  top: 5px;  right: 5px;  opacity: 0;  position: absolute;  padding: 5px 6px;  border-radius: 15px;  cursor: pointer;  font-size: 14px;  line-height: 1;  transition: opacity 0.3s ease, background-color 0.1s ease;}.posts_edit-link:hover {  background-color: white;}.posts_post:hover .posts_edit-link {  opacity: 1;}.posts_perma-link {  top: 5px;  right: 30px;  opacity: 0;  position: absolute;  padding: 5px 6px;  border-radius: 15px;  cursor: pointer;  font-size: 14px;  line-height: 1;  transition: opacity 0.3s ease, background-color 0.1s ease;}.posts_perma-link:hover {  background-color: white;}.posts_post:hover .posts_perma-link {  opacity: 1;}.editor {  display: flex;  flex: 1;  flex-direction: column;}.editor_top {  position: relative;}.editor_title {  width: 100%;  border: none;  outline: none;  box-sizing: border-box;  padding: 10px 25px;  font-size: 34px;  font-weight: bold;}.editor--draft .editor_title {  font-style: italic;  color: #aaa;}.pb-button {  outline: none;  border: transparent;  background-color: transparent;  position: absolute;  right: 14px;  top: 15px;  font-size: 18px;  cursor: pointer;  padding: 7px 20px;  border-radius: 5px;  font-weight: bold;  opacity: .5;  transition: opacity .3s ease;}.pb-button:hover {  opacity: 1;}.editor_publish {  outline: none;  border: transparent;  background-color: transparent;  position: absolute;  right: 14px;  top: 15px;  font-size: 18px;  cursor: pointer;  padding: 7px 20px;  border-radius: 5px;  font-weight: bold;  opacity: .5;  transition: opacity .3s ease;  color: #ffd5d5;  background-color: #da1212;  text-shadow: 1px 1px #7c3131;}.editor_publish:hover {  opacity: 1;}.editor_unpublish {  outline: none;  border: transparent;  background-color: transparent;  position: absolute;  right: 14px;  top: 15px;  font-size: 18px;  cursor: pointer;  padding: 7px 20px;  border-radius: 5px;  font-weight: bold;  opacity: .5;  transition: opacity .3s ease;  padding: 7px 5px 7px 0;  color: gray;}.editor_unpublish:hover {  opacity: 1;}.editor_updated {  float: right;  font-size: 14px;  font-family: Inconsolata;  color: #aaa;}.editor_word-count {  float: right;  font-size: 14px;  font-family: Inconsolata;  color: #aaa;}.editor_perma-link {  text-decoration: none;  position: relative;  top: 1px;  left: 5px;  color: #aaa;  transition: color .3s ease;}.editor_perma-link:hover {  color: black;}.editor_main {  flex: 1;  display: flex;  padding: 5px 0 0;  background-color: #b0ffd0;}.editor_main > div {  background-color: white;}.editor_no-content {  margin-top: 30px;  font-size: 30px;  color: #ddd;  font-style: italic;}.code-mirror_wrappper {  flex: 1;}@font-face {  font-family: 'Inconsolata';  font-style: normal;  font-weight: 400;  src: local('Inconsolata'), local('Inconsolata'), url('Inconsolata-Regular.ttf');}@font-face {  font-family: 'Inconsolata';  font-style: normal;  font-weight: 700;  src: local('Inconsolata Bold'), local('Inconsolata-Bold'), url('Inconsolata-Bold.ttf');}.editor_edit {  flex: 1;  display: flex;  flex-direction: column;  font-family: Inconsolata;  padding: 0 20px;  font-size: 18px;  position: relative;}.editor_edit > div {  flex: 1;}.h-head {  position: absolute;  top: 0;  left: 0;  right: 0;  background-color: rgba(236, 255, 243, 0.95);  z-index: 10;  padding: 0 25px;  font-size: 14px;  font-family: Inconsolata, monospace;}.editor_md-header {  position: absolute;  top: 0;  left: 0;  right: 0;  background-color: rgba(236, 255, 243, 0.95);  z-index: 10;  padding: 0 25px;  font-size: 14px;  font-family: Inconsolata, monospace;}.editor_display-header {  position: absolute;  top: 0;  left: 0;  right: 0;  background-color: rgba(236, 255, 243, 0.95);  z-index: 10;  padding: 0 25px;  font-size: 14px;  font-family: Inconsolata, monospace;}.editor_display {  flex: 1;  display: flex;  border-left: 5px solid #b0ffd0;  font-size: 18px;  position: relative;}.editor_rendered {  flex: 1;  overflow: auto;  padding: 40px 20px 20px;}.editor_rendered > :first-child {  margin-top: 0;}.CodeMirror-lines {  padding: 36px 0 40px 0;}.CodeMirror,.CodeMirror pre {  line-height: 1.3em;}.cm-header-1 {  font-size: 2em;}.cm-header-2 {  font-size: 1.7em;}.cm-header-3 {  font-size: 1.5em;}.cm-header-4 {  font-size: 1.3em;}/* DEFAULT THEME */.CodeMirror {  color: #6f6f6f;}.CodeMirror .CodeMirror-focused,.CodeMirror .CodeMirror-selected {  color: #555555;  background: #d9d9ff;  text-shadow: none;}.CodeMirror ::selection {  color: #555555;  background: #d9d9ff;  text-shadow: none;}.CodeMirror .cm-s-default .cm-keyword {  color: #708;}.CodeMirror .cm-s-default .cm-atom {  color: #219;}.CodeMirror .cm-s-default .cm-number {  color: #164;}.CodeMirror .cm-s-default .cm-def {  color: #00f;}.CodeMirror .cm-s-default .cm-variable {  color: black;}.CodeMirror .cm-s-default .cm-variable-2 {  color: #05a;}.CodeMirror .cm-s-default .cm-variable-3 {  color: #085;}.CodeMirror .cm-s-default .cm-property {  color: black;}.CodeMirror .cm-s-default .cm-operator {  color: black;}.CodeMirror .cm-s-default .cm-comment {  color: #a50;}.CodeMirror .cm-s-default .cm-string {  color: #a11;}.CodeMirror .cm-s-default .cm-string-2 {  color: #f50;}.CodeMirror .cm-s-default .cm-meta {  color: #555;}.CodeMirror .cm-s-default .cm-error {  color: #f00;}.CodeMirror .cm-s-default .cm-qualifier {  color: #555;}.CodeMirror .cm-s-default .cm-builtin {  color: #30a;}.CodeMirror .cm-s-default .cm-bracket {  color: #997;}.CodeMirror .cm-s-default .cm-tag {  color: #170;}.CodeMirror .cm-s-default .cm-attribute {  color: #00c;}.CodeMirror .cm-s-default .cm-header {  color: blue;}.CodeMirror .cm-s-default .cm-quote {  color: #090;}.CodeMirror .cm-s-default .cm-hr {  color: #999;}.CodeMirror .cm-s-default .cm-link {  color: #00c;}.CodeMirror .cm-negative {  color: #d44;}.CodeMirror .cm-positive {  color: #292;}.CodeMirror .cm-header,.CodeMirror .cm-strong {  font-weight: bold;}.CodeMirror .cm-em {  font-style: italic;}.CodeMirror .cm-link {  text-decoration: underline;}.CodeMirror .cm-invalidchar {  color: #f00;}.CodeMirror .cm-header {  color: #000;  font-size: 1.4em;  line-height: 1.4em;  font-weight: bold;}.CodeMirror .cm-variable-2,.CodeMirror .cm-variable-3,.CodeMirror .cm-keyword {  color: #6f6f6f;}.CodeMirror .cm-string,.CodeMirror .cm-strong,.CodeMirror .cm-link,.CodeMirror .cm-comment,.CodeMirror .cm-quote,.CodeMirror .cm-number,.CodeMirror .cm-atom,.CodeMirror .cm-tag {  color: #000;  font-weight: bold;}.new-post {  cursor: pointer;  position: relative;}.new-post_button {  padding: 10px 20px;  color: #6eaeff;  transition: background-color 0.3s ease;}.new-post_button i {  margin-right: 5px;}.new-post_button:hover {  background-color: #dfebff;}.new-post_input {  box-sizing: border-box;  padding: 10px 20px;  font-size: 20px;  width: 100%;  height: 52px;  outline: none;  border: none;}.m-icon-button {  cursor: pointer;  position: absolute;  top: 15px;  opacity: .5;  transition: opacity .3s ease;}.m-icon-button:hover {  opacity: 1;}.new-post_ok {  right: 35px;  color: #0066ff;  cursor: pointer;  position: absolute;  top: 15px;  opacity: .5;  transition: opacity .3s ease;}.new-post_ok:hover {  opacity: 1;}.new-post_cancel {  right: 10px;  color: #ff7373;  cursor: pointer;  position: absolute;  top: 15px;  opacity: .5;  transition: opacity .3s ease;}.new-post_cancel:hover {  opacity: 1;}.config-dropper {  position: absolute;  top: 18px;  right: 135px;}.config-dropper_handle {  width: 30px;  text-align: center;  border-top-right-radius: 10px;  border-bottom-right-radius: 10px;  cursor: pointer;}.config-dropper--open .config-dropper_handle {  background-color: black;  color: white;}.config {  position: absolute;  top: 0;  right: 30px;  z-index: 100;  background-color: black;  padding: 10px;  border-radius: 10px;  border-top-right-radius: 0;  color: white;  font-size: 16px;  line-height: 16px;  width: 200px;}.config_close {  position: absolute;  right: 15px;  color: white;}.config_title {  font-size: 14px;  line-height: 14px;}.config_section-title {  font-size: 14px;  line-height: 14px;  margin: 5px 0;  color: #44CA0F;}.m-config-input {  background-color: transparent;  border: 1px solid #777;  color: white;  outline: none;  border-radius: 5px;  box-sizing: border-box;  width: 100%;  padding: 1px 5px;}.config_date {  background-color: transparent;  border: 1px solid #777;  color: white;  outline: none;  border-radius: 5px;  box-sizing: border-box;  width: 100%;  padding: 1px 5px;  margin: 5px 0;}.autolist_item {  position: relative;  border-radius: 5px;  transition: background-color 0.2s ease;}.autolist_item:hover {  background-color: #333;}.autolist_del {  position: absolute;  right: 5px;  top: 5px;  cursor: pointer;  color: #ccc;  transition: color .3s ease;}.autolist_del:hover {  color: white;}.autolist_show {  padding: 5px 6px;  cursor: pointer;}.autolist_show--new {  color: #aaa;}.autolist_input {  background-color: transparent;  border: 1px solid #777;  color: white;  outline: none;  border-radius: 5px;  box-sizing: border-box;  width: 100%;  padding: 1px 5px;}.about {  padding: 50px;  max-width: 600px;}.about h1 {  font-size: 2em;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog-cine/admin/bundle.js"/>
      <url>/blog-cine/admin/bundle.js</url>
      
        <content type="html"><![CDATA[(function e(t, n, r) {  function s(o, u) {    if (!n[o]) {      if (!t[o]) {        var a = typeof require == "function" && require;        if (!u && a) return a(o, !0);        if (i) return i(o, !0);        throw new Error("Cannot find module '" + o + "'");      }      var f = (n[o] = { exports: {} });      t[o][0].call(        f.exports,        function (e) {          var n = t[o][1][e];          return s(n ? n : e);        },        f,        f.exports,        e,        t,        n,        r      );    }    return n[o].exports;  }  var i = typeof require == "function" && require;  for (var o = 0; o < r.length; o++) s(r[o]);  return s;})(  {    1: [      function (require, module, exports) {        /** @jsx React.DOM */ var React = require("react");        var About = React.createClass({          displayName: "About",          render: function () {            return React.DOM.div(              { className: "about" },              React.DOM.h1(null, "This is the Hexo Admin Plugin"),              React.DOM.p(                null,                React.DOM.strong(                  null,                  "Goal: Provide an awesome admin experience for managing your blog."                )              ),              React.DOM.p(                null,                "Useful links:",                React.DOM.ul(                  null,                  React.DOM.li(                    null,                    React.DOM.a({ href: "http://hexo.io" }, "Hexo site")                  ),                  React.DOM.li(                    null,                    React.DOM.a(                      { href: "https://github.com/jaredly/hexo-admin-plugin" },                      "Github page for this plugin"                    )                  )                )              )            );          },        });        module.exports = About;      },      { react: 232 },    ],    2: [      function (require, module, exports) {        /** @jsx React.DOM */        var types = {          rest: require("./rest"),        };        var mod = {          init: function (type, config) {            if ("string" === typeof type) {              type = types[type];            }            var api = type(config);            for (var name in api) {              mod[name] = api[name];            }          },        };        module.exports = mod;      },      { "./rest": 3 },    ],    3: [      function (require, module, exports) {        /** @jsx React.DOM */        var request = require("superagent");        var Promise = require("es6-promise").Promise;        function _post(baseUrl, url, data) {          return new Promise(function (f, r) {            var req = request.post(baseUrl + url);            if (data) {              req = req.send(data);            }            req.end(function (err, res) {              if (err) return r(err);              f(res.body);            });          });        }        function _get(baseUrl, url, params) {          return new Promise(function (f, r) {            var req = request.get(baseUrl + url);            if (params) {              req = req.query(params);            }            req.end(function (err, res) {              if (err) return r(err);              f(res.body);            });          });        }        module.exports = function (baseUrl) {          var post = _post.bind(null, baseUrl);          var get = _get.bind(null, baseUrl);          return {            posts: function () {              return get("/posts/list");            },            post: function (id, data) {              if (data) return post("/posts/" + id, data);              return get("/posts/" + id);            },            newPost: function (title) {              return post("/posts/new", { title: title });            },            uploadImage: function (data) {              return post("/images/upload", { data: data });            },            remove: function (id) {              return post("/posts/" + id + "/remove");            },            publish: function (id) {              return post("/posts/" + id + "/publish");            },            unpublish: function (id) {              return post("/posts/" + id + "/unpublish");            },            tagsAndCategories: function () {              return get("/tags-and-categories");            },          };        };      },      { "es6-promise": 28, superagent: 233 },    ],    4: [      function (require, module, exports) {        /** @jsx React.DOM */        var Link = require("react-router").Link;        var React = require("react");        var App = React.createClass({          displayName: "App",          render: function () {            return React.DOM.div(              { className: "app" },              React.DOM.div(                { className: "app_header" },                React.DOM.img({ src: "logo.png", className: "app_logo" }),                React.DOM.span({ className: "app_title" }, "Hexo Admin"),                React.DOM.ul(                  { className: "app_nav" },                  React.DOM.li(null, Link({ to: "posts" }, "Posts")),                  React.DOM.li(null, Link({ to: "about" }, "About"))                )              ),              React.DOM.div(                { className: "app_main" },                this.props.activeRouteHandler(null)              )            );          },        });        module.exports = App;      },      { react: 232, "react-router": 53 },    ],    5: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react/addons");        var cx = React.addons.classSet;        var AutoList = React.createClass({          displayName: "AutoList",          getInitialState: function () {            return {              selected: null,              text: "",            };          },          componentDidUpdate: function (prevProps, prevState) {            if (prevState.selected === null && this.state.selected !== null) {              setTimeout(                function () {                  return this.refs.input.getDOMNode().focus();                }.bind(this),                100              );            }          },          _onChange: function (e) {            this.setState({ text: e.target.value });          },          _onEdit: function (i, e) {            if (e.button !== 0) return;            e.preventDefault();            e.stopPropagation();            this.setState({              selected: i,              text: this.props.values[i] || "",            });          },          _onBlur: function () {            var values = this.props.values.slice();            if (this.props.values.indexOf(this.state.text) === -1) {              if (this.state.selected >= values.length) {                if (this.state.text) {                  values.push(this.state.text);                }              } else {                values[this.state.selected] = this.state.text;              }            }            this.setState({              selected: null,              text: "",            });            this.props.onChange(values);          },          _onRemove: function (i) {            var values = this.props.values.slice();            if (i >= values.length) return;            values.splice(i, 1);            if (this.state.selected !== null && i < this.state.selected) {              this.setState({ selected: i - 1 });            }            this.props.onChange(values);          },          _onKeyDown: function (e) {            if (e.key === "Enter") {              if (!this.state.text) return;              this.addAfter();            }          },          addAfter: function () {            if (this.props.values.indexOf(this.state.text) !== -1) {              return;            }            var values = this.props.values.slice();            if (this.state.selected === values.length) {              values.push(this.state.text);              this.props.onChange(values);              return this.setState({                text: "",                selected: values.length,              });            }            values[this.state.selected] = this.state.text;            values.splice(this.state.selected + 1, 0, "");            this.props.onChange(values);            this.setState({              selected: this.state.selected + 1,              text: "",            });          },          render: function () {            var values = this.props.values.concat(["Add new"]);            return React.DOM.div(              { className: "autolist" },              values.map(                function (item, i) {                  return React.DOM.div(                    { key: item, className: "autolist_item" },                    i === this.state.selected                      ? React.DOM.input({                          ref: "input",                          className: "autolist_input",                          value: this.state.text,                          onBlur: this._onBlur,                          onChange: this._onChange,                          onKeyDown: this._onKeyDown,                        })                      : React.DOM.div(                          {                            className: cx({                              autolist_show: true,                              "autolist_show--new": i === values.length - 1,                            }),                            onMouseDown: this._onEdit.bind(null, i),                          },                          item                        ),                    i < values.length - 1 &&                      React.DOM.i({                        className: "autolist_del fa fa-times",                        onClick: this._onRemove.bind(null, i),                      })                  );                }.bind(this)              )            );          },        });        module.exports = AutoList;      },      { "react/addons": 73 },    ],    6: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react");        var CM = require("code-mirror");        var PT = React.PropTypes;        var api = require("./api");        var CodeMirror = React.createClass({          displayName: "CodeMirror",          propTypes: {            onScroll: PT.func,          },          componentDidUpdate: function (prevProps) {            if (prevProps.initialValue !== this.props.initialValue) {              this.cm.setValue(this.props.initialValue);            }          },          componentDidMount: function () {            require("code-mirror/mode/markdown");            this.cm = CM(this.getDOMNode(), {              value: this.props.initialValue || "",              theme: require("code-mirror/theme/default"),              mode: "markdown",              lineWrapping: true,            });            this.cm.on(              "change",              function (cm) {                this.props.onChange(cm.getValue());              }.bind(this)            );            this.cm.on(              "scroll",              function (cm) {                var node = cm.getScrollerElement();                var max =                  node.scrollHeight - node.getBoundingClientRect().height;                this.props.onScroll(node.scrollTop / max);              }.bind(this)            );            var box = this.getDOMNode().getBoundingClientRect();            this.cm.setSize(box.width, box.height);            window.addEventListener("resize", this._onResize);            document.addEventListener("paste", this._onPaste);          },          _onResize: function () {            var box = this.getDOMNode().getBoundingClientRect();            this.cm.setSize(box.width, box.height);          },          componentWillUnmount: function () {            document.removeEventListener("paste", this._onPaste);            document.removeEventListener("resize", this._onResize);          },          _onPaste: function (event) {            var items = (              event.clipboardData || event.originalEvent.clipboardData            ).items;            if (!items.length) return;            var blob = items[0].getAsFile();            if (!blob) return;            var reader = new FileReader();            reader.onload = function (event) {              api.uploadImage(event.target.result).then(                function (src) {                  return this.cm.replaceSelection(                    "![pasted image](" + src + ")"                  );                }.bind(this)              );            }.bind(this);            reader.readAsDataURL(blob);          },          render: function () {            return React.DOM.div(null);          },        });        module.exports = CodeMirror;      },      {        "./api": 2,        "code-mirror": 22,        "code-mirror/mode/markdown": 23,        "code-mirror/theme/default": 26,        react: 232,      },    ],    7: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react/addons");        var AutoList = require("./auto-list");        var moment = require("moment");        var _ = require("lodash");        var cx = React.addons.classSet;        var dateFormat = "MMM D YYYY HH:mm";        function toText(lst, map) {          return lst.map(function (name) {            return map[name] || name;          });        }        var ConfigDropper = React.createClass({          displayName: "ConfigDropper",          getInitialState: function () {            var tac = this.props.tagsAndCategories;            return {              open: false,              date: moment(this.props.post.date).format(dateFormat),              tags: toText(this.props.post.tags, tac.tags),              categories: toText(this.props.post.categories, tac.categories),            };          },          componentWillReceiveProps: function (nextProps) {            if (nextProps.post === this.props.post) {              return;            }            var tac = nextProps.tagsAndCategories;            this.setState({              date: moment(nextProps.post.date).format(dateFormat),              tags: toText(nextProps.post.tags, tac.tags),              categories: toText(nextProps.post.categories, tac.categories),            });          },          componentDidUpdate: function (prevProps, prevState) {            if (this.state.open && !prevState.open) {              document.addEventListener("mousedown", this._globalMouseDown);            }            if (!this.state.open && prevState.open) {              document.removeEventListener("mousedown", this._globalMouseDown);            }          },          _globalMouseDown: function (e) {            var mine = this.getDOMNode();            var node = e.target;            while (node) {              if (!node.parentNode) return;              node = node.parentNode;              if (node === document.body) break;              if (node === mine) return;            }            this._onClose();          },          _toggleShow: function () {            if (this.state.open) {              this.save();            }            this.setState({              open: !this.state.open,            });          },          _onClose: function () {            this.save();            this.setState({ open: false });          },          _onChangeDate: function (e) {            this.setState({              date: e.target.value,            });          },          _onChange: function (attr, value) {            var update = {};            update[attr] = value;            this.setState(update);          },          save: function () {            var date = moment(this.state.date);            if (!date.isValid()) {              date = moment(this.props.post.date);            }            var tac = this.props.tagsAndCategories;            var tags = toText(this.props.post.tags, tac.tags);            var categories = toText(this.props.post.categories, tac.categories);            var textDate = date.toISOString();            if (              textDate === this.props.post.date &&              _.isEqual(this.state.categories, categories) &&              _.isEqual(this.state.tags, tags)            ) {              return;            }            this.props.onChange({              date: date.toISOString(),              categories: this.state.categories,              tags: this.state.tags,            });          },          config: function () {            return React.DOM.div(              { className: "config" },              React.DOM.div(                { className: "config_section" },                React.DOM.div({ className: "config_section-title" }, "Date"),                React.DOM.input({                  className: "config_date",                  value: this.state.date,                  onChange: this._onChangeDate,                })              ),              React.DOM.div(                { className: "config_section" },                React.DOM.div({ className: "config_section-title" }, "Tags"),                AutoList({                  options: this.props.tagsAndCategories.tags,                  values: this.state.tags,                  onChange: this._onChange.bind(null, "tags"),                })              ),              React.DOM.div(                { className: "config_section" },                React.DOM.div(                  { className: "config_section-title" },                  "Categories"                ),                AutoList({                  options: this.props.tagsAndCategories.categories,                  values: this.state.categories,                  onChange: this._onChange.bind(null, "categories"),                })              )            );          },          render: function () {            return React.DOM.div(              {                className: cx({                  "config-dropper": true,                  "config-dropper--open": this.state.open,                }),              },              React.DOM.div(                {                  className: "config-dropper_handle",                  onClick: this._toggleShow,                },                React.DOM.i({ className: "fa fa-gear" })              ),              this.state.open && this.config()            );          },        });        module.exports = ConfigDropper;      },      { "./auto-list": 5, lodash: 38, moment: 40, "react/addons": 73 },    ],    8: [      function (require, module, exports) {        /** @jsx React.DOM */ var p = require("es6-promise"),          Promise = p.Promise;        module.exports = function (fetch) {          return {            getInitialState: function () {              return {};            },            componentWillMount: function () {              this.loadData(this.props);            },            componentWillReceiveProps: function (nextProps) {              this.loadData(nextProps);            },            loadData: function (props) {              var items = fetch(props.params);              Object.keys(items).forEach(                function (name) {                  Promise.resolve(items[name]).then(                    function (data) {                      if (!this.isMounted()) return;                      var update = {};                      update[name] = data;                      this.setState(update);                      if (this.dataDidLoad) {                        this.dataDidLoad(name, data);                      }                    }.bind(this)                  );                }.bind(this)              );            },          };        };      },      { "es6-promise": 28 },    ],    9: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react/addons");        var cx = React.addons.classSet;        var Promise = require("es6-promise").Promise;        var PT = React.PropTypes;        var CodeMirror = require("./code-mirror");        var SinceWhen = require("./since-when");        var Rendered = require("./rendered");        var ConfigDropper = require("./config-dropper");        var Editor = React.createClass({          displayName: "Editor",          propTypes: {            raw: PT.string,            onChangeTitle: PT.func,            title: PT.string,            updated: PT.object,            isDraft: PT.bool,            onPublish: PT.func.isRequired,            onUnpublish: PT.func.isRequired,            tagsAndCategories: PT.object,          },          handleChangeTitle: function (e) {            return this.props.onChangeTitle(e.target.value);          },          handleScroll: function (percent) {            var node = this.refs.rendered.getDOMNode();            var height = node.getBoundingClientRect().height;            node.scrollTop = (node.scrollHeight - height) * percent;          },          render: function () {            return React.DOM.div(              {                className: cx({                  editor: true,                  "editor--draft": this.props.isDraft,                }),              },              React.DOM.div(                { className: "editor_top" },                React.DOM.input({                  className: "editor_title",                  value: this.props.title,                  onChange: this.handleChangeTitle,                }),                ConfigDropper({                  post: this.props.post,                  tagsAndCategories: this.props.tagsAndCategories,                  onChange: this.props.onChange,                }),                this.props.isDraft                  ? React.DOM.button(                      {                        className: "editor_publish",                        onClick: this.props.onPublish,                      },                      "Publish"                    )                  : React.DOM.button(                      {                        className: "editor_unpublish",                        onClick: this.props.onUnpublish,                      },                      "Unpublish"                    )              ),              React.DOM.div(                { className: "editor_main" },                React.DOM.div(                  { className: "editor_edit" },                  React.DOM.div(                    { className: "editor_md-header" },                    this.props.updated &&                      SinceWhen({                        className: "editor_updated",                        prefix: "saved ",                        time: this.props.updated,                      }),                    "Markdown"                  ),                  CodeMirror({                    onScroll: this.handleScroll,                    initialValue: this.props.raw,                    onChange: this.props.onChangeContent,                  })                ),                React.DOM.div(                  { className: "editor_display" },                  React.DOM.div(                    { className: "editor_display-header" },                    React.DOM.span(                      { className: "editor_word-count" },                      this.props.wordCount,                      " words"                    ),                    "Preview",                    " ",                    React.DOM.a(                      {                        className: "editor_perma-link",                        href: this.props.previewLink,                        target: "_blank",                      },                      React.DOM.i({ className: "fa fa-link" }),                      " ",                      this.props.previewLink                    )                  ),                  Rendered({                    ref: "rendered",                    className: "editor_rendered",                    text: this.props.rendered,                  })                )              )            );          },        });        module.exports = Editor;      },      {        "./code-mirror": 6,        "./config-dropper": 7,        "./rendered": 14,        "./since-when": 16,        "es6-promise": 28,        "react/addons": 73,      },    ],    10: [      function (require, module, exports) {        /** @jsx React.DOM */        var router = require("./router");        var React = require("react");        module.exports = function (node) {          React.renderComponent(router(), node);        };      },      { "./router": 15, react: 232 },    ],    11: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react");        var PT = React.PropTypes;        var api = require("./api");        var NewPost = React.createClass({          displayName: "NewPost",          propTypes: {            onNew: PT.func,          },          getInitialState: function () {            return {              showing: false,              loading: true,              text: "Untitled",            };          },          componentDidUpdate: function (prevProps, prevState) {            if (this.state.showing && !prevState.showing) {              var node = this.refs.input.getDOMNode();              node.focus();              node.selectionStart = 0;              node.selectionEnd = node.value.length;            }          },          _onKeydown: function (e) {            if (e.key === "Enter") {              this._onSubmit();            }          },          _onShow: function () {            this.setState({ showing: true });          },          _onBlur: function () {            if (this.state.showing) {              this._onCancel();            }          },          _onSubmit: function () {            this.setState({ loading: true, showing: false });            api.newPost(this.state.text).then(              function (post) {                this.setState({ showing: false, text: "Untitled" });                this.props.onNew(post);              }.bind(this),              function (err) {                console.error("Failed! to make post", err);              }            );          },          _onCancel: function () {            this.setState({ showing: false });          },          _onChange: function (e) {            this.setState({              text: e.target.value,            });          },          render: function () {            if (!this.state.showing) {              return React.DOM.div(                { className: "new-post", onClick: this._onShow },                React.DOM.div(                  { className: "new-post_button" },                  React.DOM.i({ className: "fa fa-plus" }),                  " ",                  "New Post"                )              );            }            return React.DOM.div(              { className: "new-post" },              React.DOM.input({                className: "new-post_input",                ref: "input",                value: this.state.text,                onBlur: this._onBlur,                onKeyPress: this._onKeydown,                onChange: this._onChange,              }),              React.DOM.i({                className: "fa fa-check-circle new-post_ok",                onClick: this._onSubmit,              }),              React.DOM.i({                className: "fa fa-times-circle new-post_cancel",                onClick: this._onCancel,              })            );          },        });        module.exports = NewPost;      },      { "./api": 2, react: 232 },    ],    12: [      function (require, module, exports) {        /** @jsx React.DOM */        var DataFetcher = require("./data-fetcher");        var api = require("./api");        var React = require("react/addons");        var cx = React.addons.classSet;        var Promise = require("es6-promise").Promise;        var marked = require("marked");        var Editor = require("./editor");        var _ = require("lodash");        var moment = require("moment");        var Post = React.createClass({          displayName: "Post",          mixins: [            DataFetcher(function (params) {              return {                post: api.post(params.postId),                tagsAndCategories: api.tagsAndCategories(),              };            }),          ],          getInitialState: function () {            return {              updated: moment(),            };          },          componentDidMount: function () {            this._post = _.debounce(              function (update) {                var now = moment();                api.post(this.props.params.postId, update).then(                  function () {                    this.setState({                      updated: now,                    });                  }.bind(this)                );              }.bind(this),              1000,              { trailing: true, loading: true }            );          },          handleChange: function (update) {            var now = moment();            api.post(this.props.params.postId, update).then(              function (data) {                this.setState({                  tagsAndCategories: data.tagsAndCategories,                  post: data.post,                  updated: now,                });              }.bind(this)            );          },          handleChangeContent: function (text) {            if (text === this.state.raw) {              return;            }            this.setState({              raw: text,              updated: null,              rendered: marked(text),            });            this._post({ _content: text });          },          handleChangeTitle: function (title) {            if (title === this.state.title) {              return;            }            this.setState({ title: title });            this._post({ title: title });          },          handlePublish: function () {            if (!this.state.post.isDraft) return;            api.publish(this.state.post._id).then(              function (post) {                this.setState({ post: post });              }.bind(this)            );          },          handleUnpublish: function () {            if (this.state.post.isDraft) return;            api.unpublish(this.state.post._id).then(              function (post) {                this.setState({ post: post });              }.bind(this)            );          },          dataDidLoad: function (name, data) {            if (name !== "post") return;            var parts = data.raw.split("---");            var raw = parts.slice(1).join("---").trim();            this.setState({              title: data.title,              initialRaw: raw,              raw: raw,              rendered: data.content,            });          },          render: function () {            var post = this.state.post;            if (!post || !this.state.tagsAndCategories) {              return React.DOM.span(null, "Loading...");            }            var permaLink = "/" + post.path;            return Editor({              post: this.state.post,              raw: this.state.initialRaw,              wordCount: this.state.raw ? this.state.raw.split(" ").length : 0,              isDraft: post.isDraft,              updated: this.state.updated,              title: this.state.title,              rendered: this.state.rendered,              previewLink: permaLink,              onChange: this.handleChange,              onChangeContent: this.handleChangeContent,              onChangeTitle: this.handleChangeTitle,              onPublish: this.handlePublish,              onUnpublish: this.handleUnpublish,              tagsAndCategories: this.state.tagsAndCategories,            });          },        });        module.exports = Post;      },      {        "./api": 2,        "./data-fetcher": 8,        "./editor": 9,        "es6-promise": 28,        lodash: 38,        marked: 39,        moment: 40,        "react/addons": 73,      },    ],    13: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react/addons");        var cx = React.addons.classSet;        var Link = require("react-router").Link;        var Router = require("react-router");        var _ = require("lodash");        var moment = require("moment");        var SinceWhen = require("./since-when");        var Rendered = require("./rendered");        var DataFetcher = require("./data-fetcher");        var NewPost = require("./new-post");        var api = require("./api");        var Posts = React.createClass({          displayName: "Posts",          mixins: [            DataFetcher(function (params) {              return {                posts: api.posts().then(function (posts) {                  return _.sortBy(posts, ["isDraft", "date"]).reverse();                }),              };            }),          ],          getInitialState: function () {            return {              selected: 0,            };          },          _onNew: function (post) {            var posts = this.state.posts.slice();            posts.unshift(post);            this.setState({ posts: posts });            Router.transitionTo("post", { postId: post._id });          },          goTo: function (id, e) {            if (e) {              e.preventDefault();            }            Router.transitionTo("post", { postId: id });          },          render: function () {            if (!this.state.posts) {              return React.DOM.div({ className: "posts" }, "Loading...");            }            var current = this.state.posts[this.state.selected] || {};            return React.DOM.div(              { className: "posts" },              React.DOM.ul(                { className: "posts_list" },                NewPost({ onNew: this._onNew }),                this.state.posts.map(                  function (post, i) {                    return React.DOM.li(                      {                        key: post._id,                        className: cx({                          posts_post: true,                          "posts_post--draft": post.isDraft,                          "posts_post--selected": i === this.state.selected,                        }),                        onDoubleClick: this.goTo.bind(null, post._id),                        onClick: this.setState.bind(                          this,                          { selected: i },                          null                        ),                      },                      React.DOM.span(                        { className: "posts_post-title" },                        post.title                      ),                      React.DOM.span(                        { className: "posts_post-date" },                        moment(post.date).format("MMM Do YYYY")                      ),                      React.DOM.a(                        {                          className: "posts_perma-link",                          target: "_blank",                          href: "/" + post.path,                        },                        React.DOM.i({ className: "fa fa-link" })                      ),                      Link(                        {                          className: "posts_edit-link",                          to: "post",                          postId: post._id,                        },                        React.DOM.i({ className: "fa fa-pencil" })                      )                    );                  }.bind(this)                )              ),              React.DOM.div(                {                  className: cx({                    posts_display: true,                    "posts_display--draft": current.isDraft,                  }),                },                current.isDraft &&                  React.DOM.div({ className: "posts_draft-message" }, "Draft"),                Rendered({                  ref: "rendered",                  className: "posts_content",                  text: current.content,                })              )            );          },        });        module.exports = Posts;      },      {        "./api": 2,        "./data-fetcher": 8,        "./new-post": 11,        "./rendered": 14,        "./since-when": 16,        lodash: 38,        moment: 40,        "react-router": 53,        "react/addons": 73,      },    ],    14: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react");        var Rendered = React.createClass({          displayName: "Rendered",          propTypes: {            text: React.PropTypes.string,          },          render: function () {            return this.transferPropsTo(              React.DOM.div({                className: "post-content",                dangerouslySetInnerHTML: {                  __html:                    this.props.text ||                    '<h1 class="editor_no-content">There doesn\'t seem to be anything here</h1>',                },              })            );          },        });        module.exports = Rendered;      },      { react: 232 },    ],    15: [      function (require, module, exports) {        /** @jsx React.DOM */        var App = require("./app");        var Post = require("./post");        var Posts = require("./posts");        var About = require("./about");        var Route = require("react-router").Route;        module.exports = function () {          return Route(            { handler: App },            Route({ name: "posts", handler: Posts, path: "/" }),            Route({ name: "post", handler: Post, path: "/posts/:postId" }),            Route({ name: "about", handler: About })          );        };      },      {        "./about": 1,        "./app": 4,        "./post": 12,        "./posts": 13,        "react-router": 53,      },    ],    16: [      function (require, module, exports) {        /** @jsx React.DOM */        var React = require("react");        var SinceWhen = React.createClass({          displayName: "SinceWhen",          componentDidMount: function () {            this._iv = setInterval(this.tick, 5000);          },          componentWillUnmount: function () {            clearInterval(this._iv);          },          getDefaultProps: function () {            return {              prefix: "",            };          },          getInitialState: function () {            return {              time: this.props.time.fromNow(),            };          },          tick: function () {            if (!this.isMounted()) {              return clearInterval(this._iv);            }            this.setState({ time: this.props.time.fromNow() });          },          render: function () {            return this.transferPropsTo(              React.DOM.span(null, this.props.prefix + this.state.time)            );          },        });        module.exports = SinceWhen;      },      { react: 232 },    ],    17: [      function (require, module, exports) {        /** @jsx React.DOM */ module.exports = [          {            title: "Hello World",            tags: [],            categories: [],            date: "2014-07-21T01:06:00.000Z",            content:              '<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>\n<h2 id="Quick_Start">Quick Start</h2>\n<h3 id="Create_a_new_post">Create a new post</h3>\n<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>\n\n<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>\n<h3 id="Run_server">Run server</h3>\n<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>\n\n<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>\n<h3 id="Generate_static_files">Generate static files</h3>\n<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>\n\n<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>\n<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>\n<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>\n\n<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>\n',            source: "_posts/hello-world.md",            raw: 'title: Hello World\ntags: []\ncategories: []\ndate: 2014-07-20 18:06:00\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [trobuleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new "My New Post"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)',            slug: "hello-world",            updated: "2014-07-30T01:15:13.000Z",            excerpt: "",            _id: "36ybv44qew5shs2j",            comments: true,            layout: "post",            photos: [],            link: "",            path: "2014/07/20/hello-world/",            permalink: "http://yoursite.com/2014/07/20/hello-world/",            full_source: "/clone/demo-blog/source/_posts/hello-world.md",            asset_dir: "/clone/demo-blog/source/_posts/hello-world/",            isDraft: false,            isDiscarded: false,          },          {            title: "The Best Idea Ever",            tags: [],            categories: [],            date: "2014-03-03T15:23:00.000Z",            content:              '<p>So I have this idea for this treehouse, which would also be a house boat. Why has no one done this before?</p>\n<p><img src="http://www.interiordesign2014.com/wp-content/uploads/2013/07/bamboo-houseboat-250x250.jpg" alt="house boat ish"></p>\n<h2 id="Major_hurdles">Major hurdles</h2>\n<p>One of the things to worry about is how to get the houseboat up into the tree and out of it again. Possibilities include:</p>\n<ul>\n<li>Make the houseboat also be a hovecar, so that it can just fly up into the tree</li>\n<li>have an apparatus next to the tree which will lower and raise the house</li>\n<li>make the tree an actual part of the house, and have it uproot itself when you want to go into the water. Don’t magroves do this already?</li>\n</ul>\n<h2 id="Implementation:">Implementation:</h2>\n<p>TBD</p>\n<h2 id="Funding">Funding</h2>\n<p>I’ve been collecting stamps all of my life, preparing for this. How much does a treehouse usually cost, anyway? At last count, I have $302.38. Which is a ton.</p>\n',            source: "_drafts/The-Best-Idea-Ever.md",            raw: "title: The Best Idea Ever\ntags: []\ncategories: []\ndate: 2014-03-03 07:23:00\n---\nSo I have this idea for this treehouse, which would also be a house boat. Why has no one done this before?\n\n![house boat ish](http://www.interiordesign2014.com/wp-content/uploads/2013/07/bamboo-houseboat-250x250.jpg)\n\n## Major hurdles\nOne of the things to worry about is how to get the houseboat up into the tree and out of it again. Possibilities include:\n\n- Make the houseboat also be a hovecar, so that it can just fly up into the tree\n- have an apparatus next to the tree which will lower and raise the house\n- make the tree an actual part of the house, and have it uproot itself when you want to go into the water. Don't magroves do this already?\n\n## Implementation:\nTBD\n\n## Funding\nI've been collecting stamps all of my life, preparing for this. How much does a treehouse usually cost, anyway? At last count, I have $302.38. Which is a ton.",            slug: "The-Best-Idea-Ever",            updated: "2014-07-30T01:15:48.000Z",            excerpt: "",            _id: "9g1zqz2ml67493bt",            comments: true,            layout: "post",            photos: [],            link: "",            path: "2014/03/03/The-Best-Idea-Ever/",            permalink: "http://yoursite.com/2014/03/03/The-Best-Idea-Ever/",            full_source:              "/clone/demo-blog/source/_drafts/The-Best-Idea-Ever.md",            asset_dir: "/clone/demo-blog/source/_drafts/The-Best-Idea-Ever/",            isDraft: true,            isDiscarded: false,          },          {            title: "Demo Site",            tags: ["khs0fyclcklebuuh", "mgmzanv3udntfcq5"],            categories: ["247bgen6wg4wt21y", "sabslzxuqj0nryqy"],            date: "2014-07-30T01:13:00.000Z",            content:              "<p>This is totally a demo site. Some things just won’t work at all. Some things might work a bit.</p>\n",            source: "_posts/Demo-Site.md",            raw: "title: Demo Site\ntags:\n  - One tag\n  - another tag\ncategories:\n  - The Best Category\n  - Sub Cat\ndate: 2014-07-29 18:13:00\n---\nThis is totally a demo site. Some things just won't work at all. Some things might work a bit.",            slug: "Demo-Site",            updated: "2014-07-30T01:14:57.000Z",            excerpt: "",            _id: "adrf0tqxi6bs0xiz",            comments: true,            layout: "post",            photos: [],            link: "",            path: "2014/07/29/Demo-Site/",            permalink: "http://yoursite.com/2014/07/29/Demo-Site/",            full_source: "/clone/demo-blog/source/_posts/Demo-Site.md",            asset_dir: "/clone/demo-blog/source/_posts/Demo-Site/",            isDraft: false,            isDiscarded: false,          },        ];      },      {},    ],    18: [      function (require, module, exports) {        /** @jsx React.DOM */        var marked = require("marked");        var _ = require("lodash");        var anchorId = function (str) {          return str            .replace(/\s+/g, "_")            .replace(/\./g, "-")            .replace(/-{2,}/g, "-");        };        marked.setOptions({          langPrefix: "",        });        module.exports = function (data, options) {          headingId = {};          return marked(            data.text,            _.extend(              {                gfm: true,                pedantic: false,                sanitize: false,                tables: true,                breaks: true,                smartLists: true,                smartypants: true,              },              options            )          );        };      },      { lodash: 38, marked: 39 },    ],    19: [      function (require, module, exports) {        /** @jsx React.DOM */ var admin = require("../../client"),          api = require("../../client/api");        // for debugging        window.React = require("react");        api.init(require("./test-api.js"), {          posts: require("./posts.js"),          tagsAndCategories: require("./tags-and-categories.js"),        });        document.addEventListener("DOMContentLoaded", function () {          var node = document.createElement("div");          document.body.appendChild(node);          admin(node);        });      },      {        "../../client": 10,        "../../client/api": 2,        "./posts.js": 17,        "./tags-and-categories.js": 20,        "./test-api.js": 21,        react: 232,      },    ],    20: [      function (require, module, exports) {        /** @jsx React.DOM */ module.exports = {          categories: {            "247bgen6wg4wt21y": "The Best Category",            sabslzxuqj0nryqy: "Sub Cat",          },          tags: {            khs0fyclcklebuuh: "One tag",            mgmzanv3udntfcq5: "another tag",          },        };      },      {},    ],    21: [      function (require, module, exports) {        /** @jsx React.DOM */        var Promise = require("es6-promise").Promise;        var moment = require("moment");        var render = require("./render");        function newId() {          var id = "";          var chars = "abcdefghijklmnopqrstuvwxyz0123456789";          for (var i = 0; i < 10; i++) {            id += chars[parseInt(Math.random() * chars.length)];          }          return id;        }        function newPost(title) {          var slug = title.toLowerCase().replace(/ /g, "-");          return {            _id: newId(),            title: title,            tags: [],            categories: [],            date: new Date().toISOString(),            content: "",            source: "_drafts/" + slug + ".md",            raw: "title: " + title + "\n---",            slug: slug,            updated: new Date().toISOString(),            excerpt: "",            layout: "post",            isDraft: true,            isDiscarded: false,            path: moment().format("YYYY/MM/DD/") + slug + "/",          };        }        module.exports = function (config) {          var ids = {};          config.posts.forEach(function (post) {            return (ids[post._id] = post);          });          return {            posts: function () {              return Promise.resolve(config.posts);            },            post: function (id, data) {              if (data) {                for (var name in data) {                  ids[id][name] = data[name];                }                if (data._content) {                  // ids[id].raw = yfm.stringify(ids[id])                  ids[id].content = render({ text: data._content });                }                return Promise.resolve({                  post: ids[id],                  tagsAndCategories: config.tagsAndCategories,                });              }              return Promise.resolve(ids[id]);            },            newPost: function (title) {              var post = newPost(title);              ids[post._id] = post;              config.posts.push(post);              return Promise.resolve(post);            },            uploadImage: function (data) {              return Promise.resolve(null);            },            remove: function (id) {              return Promise.resolve(null);            },            publish: function (id) {              ids[id].isDraft = false;              return Promise.resolve(ids[id]);            },            unpublish: function (id) {              ids[id].isDraft = true;              return Promise.resolve(ids[id]);            },            tagsAndCategories: function () {              return Promise.resolve(config.tagsAndCategories);            },          };        };      },      { "./render": 18, "es6-promise": 28, moment: 40 },    ],    22: [      function (require, module, exports) {        // CodeMirror is the only global var we claim        module.exports = (function () {          "use strict";          // BROWSER SNIFFING          // Crude, but necessary to handle a number of hard-to-feature-detect          // bugs and behavior differences.          var gecko = /gecko\/\d/i.test(navigator.userAgent);          // IE11 currently doesn't count as 'ie', since it has almost none of          // the same bugs as earlier versions. Use ie_gt10 to handle          // incompatibilities in that version.          var old_ie = /MSIE \d/.test(navigator.userAgent);          var ie_lt8 =            old_ie &&            (document.documentMode == null || document.documentMode < 8);          var ie_lt9 =            old_ie &&            (document.documentMode == null || document.documentMode < 9);          var ie_lt10 =            old_ie &&            (document.documentMode == null || document.documentMode < 10);          var ie_gt10 = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);          var ie = old_ie || ie_gt10;          var webkit = /WebKit\//.test(navigator.userAgent);          var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);          var chrome = /Chrome\//.test(navigator.userAgent);          var opera = /Opera\//.test(navigator.userAgent);          var safari = /Apple Computer/.test(navigator.vendor);          var khtml = /KHTML\//.test(navigator.userAgent);          var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(            navigator.userAgent          );          var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(            navigator.userAgent          );          var phantom = /PhantomJS/.test(navigator.userAgent);          var ios =            /AppleWebKit/.test(navigator.userAgent) &&            /Mobile\/\w+/.test(navigator.userAgent);          // This is woefully incomplete. Suggestions for alternative methods welcome.          var mobile =            ios ||            /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(              navigator.userAgent            );          var mac = ios || /Mac/.test(navigator.platform);          var windows = /win/i.test(navigator.platform);          var opera_version =            opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);          if (opera_version) opera_version = Number(opera_version[1]);          if (opera_version && opera_version >= 15) {            opera = false;            webkit = true;          }          // Some browsers use the wrong event properties to signal cmd/ctrl on OS X          var flipCtrlCmd =            mac &&            (qtwebkit ||              (opera && (opera_version == null || opera_version < 12.11)));          var captureMiddleClick = gecko || (ie && !ie_lt9);          // Optimize some code when these features are not used          var sawReadOnlySpans = false,            sawCollapsedSpans = false;          // CONSTRUCTOR          function CodeMirror(place, options) {            if (!(this instanceof CodeMirror))              return new CodeMirror(place, options);            this.options = options = options || {};            // Determine effective options based on given values and defaults.            for (var opt in defaults)              if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))                options[opt] = defaults[opt];            setGuttersForLineNumbers(options);            var docStart =              typeof options.value == "string" ? 0 : options.value.first;            var display = (this.display = makeDisplay(place, docStart));            display.wrapper.CodeMirror = this;            updateGutters(this);            if (options.autofocus && !mobile) focusInput(this);            this.state = {              keyMaps: [],              overlays: [],              modeGen: 0,              overwrite: false,              focused: false,              suppressEdits: false,              pasteIncoming: false,              cutIncoming: false,              draggingText: false,              highlight: new Delayed(),            };            themeChanged(this);            if (options.lineWrapping)              this.display.wrapper.className += " CodeMirror-wrap";            var doc = options.value;            if (typeof doc == "string")              doc = new Doc(options.value, options.mode);            operation(this, attachDoc)(this, doc);            // Override magic textarea content restore that IE sometimes does            // on our hidden textarea on reload            if (old_ie) setTimeout(bind(resetInput, this, true), 20);            registerEventHandlers(this);            // IE throws unspecified error in certain cases, when            // trying to access activeElement before onload            var hasFocus;            try {              hasFocus = document.activeElement == display.input;            } catch (e) {}            if (hasFocus || (options.autofocus && !mobile))              setTimeout(bind(onFocus, this), 20);            else onBlur(this);            operation(this, function () {              for (var opt in optionHandlers)                if (optionHandlers.propertyIsEnumerable(opt))                  optionHandlers[opt](this, options[opt], Init);              for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);            })();          }          // DISPLAY CONSTRUCTOR          function makeDisplay(place, docStart) {            var d = {};            var input = (d.input = elt(              "textarea",              null,              null,              "position: absolute; padding: 0; width: 1px; height: 1em; outline: none"            ));            if (webkit) input.style.width = "1000px";            else input.setAttribute("wrap", "off");            // if border: 0; -- iOS fails to open keyboard (issue #1287)            if (ios) input.style.border = "1px solid black";            input.setAttribute("autocorrect", "off");            input.setAttribute("autocapitalize", "off");            input.setAttribute("spellcheck", "false");            // Wraps and hides input textarea            d.inputDiv = elt(              "div",              [input],              null,              "overflow: hidden; position: relative; width: 3px; height: 0px;"            );            // The actual fake scrollbars.            d.scrollbarH = elt(              "div",              [elt("div", null, null, "height: 1px")],              "CodeMirror-hscrollbar"            );            d.scrollbarV = elt(              "div",              [elt("div", null, null, "width: 1px")],              "CodeMirror-vscrollbar"            );            d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");            d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");            // DIVs containing the selection and the actual code            d.lineDiv = elt("div", null, "CodeMirror-code");            d.selectionDiv = elt(              "div",              null,              null,              "position: relative; z-index: 1"            );            // Blinky cursor, and element used to ensure cursor fits at the end of a line            d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");            // Secondary cursor, shown when on a 'jump' in bi-directional text            d.otherCursor = elt(              "div",              "\u00a0",              "CodeMirror-cursor CodeMirror-secondarycursor"            );            // Used to measure text size            d.measure = elt("div", null, "CodeMirror-measure");            // Wraps everything that needs to exist inside the vertically-padded coordinate system            d.lineSpace = elt(              "div",              [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],              null,              "position: relative; outline: none"            );            // Moved around its parent to cover visible view            d.mover = elt(              "div",              [elt("div", [d.lineSpace], "CodeMirror-lines")],              null,              "position: relative"            );            // Set to the height of the text, causes scrolling            d.sizer = elt("div", [d.mover], "CodeMirror-sizer");            // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers            d.heightForcer = elt(              "div",              null,              null,              "position: absolute; height: " +                scrollerCutOff +                "px; width: 1px;"            );            // Will contain the gutters, if any            d.gutters = elt("div", null, "CodeMirror-gutters");            d.lineGutter = null;            // Provides scrolling            d.scroller = elt(              "div",              [d.sizer, d.heightForcer, d.gutters],              "CodeMirror-scroll"            );            d.scroller.setAttribute("tabIndex", "-1");            // The element in which the editor lives.            d.wrapper = elt(              "div",              [                d.inputDiv,                d.scrollbarH,                d.scrollbarV,                d.scrollbarFiller,                d.gutterFiller,                d.scroller,              ],              "CodeMirror"            );            // Work around IE7 z-index bug            if (ie_lt8) {              d.gutters.style.zIndex = -1;              d.scroller.style.paddingRight = 0;            }            if (place.appendChild) place.appendChild(d.wrapper);            else place(d.wrapper);            // Needed to hide big blue blinking cursor on Mobile Safari            if (ios) input.style.width = "0px";            if (!webkit) d.scroller.draggable = true;            // Needed to handle Tab key in KHTML            if (khtml) {              d.inputDiv.style.height = "1px";              d.inputDiv.style.position = "absolute";            }            // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).            else if (ie_lt8)              d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth =                "18px";            // Current visible range (may be bigger than the view window).            d.viewOffset = d.lastSizeC = 0;            d.showingFrom = d.showingTo = docStart;            // Used to only resize the line number gutter when necessary (when            // the amount of lines crosses a boundary that makes its width change)            d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;            // See readInput and resetInput            d.prevInput = "";            // Set to true when a non-horizontal-scrolling widget is added. As            // an optimization, widget aligning is skipped when d is false.            d.alignWidgets = false;            // Flag that indicates whether we currently expect input to appear            // (after some event like 'keypress' or 'input') and are polling            // intensively.            d.pollingFast = false;            // Self-resetting timeout for the poller            d.poll = new Delayed();            d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;            d.measureLineCache = [];            d.measureLineCachePos = 0;            // Tracks when resetInput has punted to just putting a short            // string instead of the (large) selection.            d.inaccurateSelection = false;            // Tracks the maximum line length so that the horizontal scrollbar            // can be kept static when scrolling.            d.maxLine = null;            d.maxLineLength = 0;            d.maxLineChanged = false;            // Used for measuring wheel scrolling granularity            d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;            return d;          }          // STATE UPDATES          // Used to get the editor into a consistent state again when options change.          function loadMode(cm) {            cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);            resetModeState(cm);          }          function resetModeState(cm) {            cm.doc.iter(function (line) {              if (line.stateAfter) line.stateAfter = null;              if (line.styles) line.styles = null;            });            cm.doc.frontier = cm.doc.first;            startWorker(cm, 100);            cm.state.modeGen++;            if (cm.curOp) regChange(cm);          }          function wrappingChanged(cm) {            if (cm.options.lineWrapping) {              cm.display.wrapper.className += " CodeMirror-wrap";              cm.display.sizer.style.minWidth = "";            } else {              cm.display.wrapper.className =                cm.display.wrapper.className.replace(" CodeMirror-wrap", "");              computeMaxLength(cm);            }            estimateLineHeights(cm);            regChange(cm);            clearCaches(cm);            setTimeout(function () {              updateScrollbars(cm);            }, 100);          }          function estimateHeight(cm) {            var th = textHeight(cm.display),              wrapping = cm.options.lineWrapping;            var perLine =              wrapping &&              Math.max(                5,                cm.display.scroller.clientWidth / charWidth(cm.display) - 3              );            return function (line) {              if (lineIsHidden(cm.doc, line)) return 0;              else if (wrapping)                return (Math.ceil(line.text.length / perLine) || 1) * th;              else return th;            };          }          function estimateLineHeights(cm) {            var doc = cm.doc,              est = estimateHeight(cm);            doc.iter(function (line) {              var estHeight = est(line);              if (estHeight != line.height) updateLineHeight(line, estHeight);            });          }          function keyMapChanged(cm) {            var map = keyMap[cm.options.keyMap],              style = map.style;            cm.display.wrapper.className =              cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +              (style ? " cm-keymap-" + style : "");          }          function themeChanged(cm) {            cm.display.wrapper.className =              cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +              cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");            clearCaches(cm);          }          function guttersChanged(cm) {            updateGutters(cm);            regChange(cm);            setTimeout(function () {              alignHorizontally(cm);            }, 20);          }          function updateGutters(cm) {            var gutters = cm.display.gutters,              specs = cm.options.gutters;            removeChildren(gutters);            for (var i = 0; i < specs.length; ++i) {              var gutterClass = specs[i];              var gElt = gutters.appendChild(                elt("div", null, "CodeMirror-gutter " + gutterClass)              );              if (gutterClass == "CodeMirror-linenumbers") {                cm.display.lineGutter = gElt;                gElt.style.width = (cm.display.lineNumWidth || 1) + "px";              }            }            gutters.style.display = i ? "" : "none";          }          function lineLength(doc, line) {            if (line.height == 0) return 0;            var len = line.text.length,              merged,              cur = line;            while ((merged = collapsedSpanAtStart(cur))) {              var found = merged.find();              cur = getLine(doc, found.from.line);              len += found.from.ch - found.to.ch;            }            cur = line;            while ((merged = collapsedSpanAtEnd(cur))) {              var found = merged.find();              len -= cur.text.length - found.from.ch;              cur = getLine(doc, found.to.line);              len += cur.text.length - found.to.ch;            }            return len;          }          function computeMaxLength(cm) {            var d = cm.display,              doc = cm.doc;            d.maxLine = getLine(doc, doc.first);            d.maxLineLength = lineLength(doc, d.maxLine);            d.maxLineChanged = true;            doc.iter(function (line) {              var len = lineLength(doc, line);              if (len > d.maxLineLength) {                d.maxLineLength = len;                d.maxLine = line;              }            });          }          // Make sure the gutters options contains the element          // "CodeMirror-linenumbers" when the lineNumbers option is true.          function setGuttersForLineNumbers(options) {            var found = indexOf(options.gutters, "CodeMirror-linenumbers");            if (found == -1 && options.lineNumbers) {              options.gutters = options.gutters.concat([                "CodeMirror-linenumbers",              ]);            } else if (found > -1 && !options.lineNumbers) {              options.gutters = options.gutters.slice(0);              options.gutters.splice(found, 1);            }          }          // SCROLLBARS          // Re-synchronize the fake scrollbars with the actual size of the          // content. Optionally force a scrollTop.          function updateScrollbars(cm) {            var d = cm.display,              docHeight = cm.doc.height;            var totalHeight = docHeight + paddingVert(d);            d.sizer.style.minHeight = d.heightForcer.style.top =              totalHeight + "px";            d.gutters.style.height =              Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) +              "px";            var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);            var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;            var needsV = scrollHeight > d.scroller.clientHeight + 1;            if (needsV) {              d.scrollbarV.style.display = "block";              d.scrollbarV.style.bottom = needsH                ? scrollbarWidth(d.measure) + "px"                : "0";              // A bug in IE8 can cause this value to be negative, so guard it.              d.scrollbarV.firstChild.style.height =                Math.max(                  0,                  scrollHeight -                    d.scroller.clientHeight +                    d.scrollbarV.clientHeight                ) + "px";            } else {              d.scrollbarV.style.display = "";              d.scrollbarV.firstChild.style.height = "0";            }            if (needsH) {              d.scrollbarH.style.display = "block";              d.scrollbarH.style.right = needsV                ? scrollbarWidth(d.measure) + "px"                : "0";              d.scrollbarH.firstChild.style.width =                d.scroller.scrollWidth -                d.scroller.clientWidth +                d.scrollbarH.clientWidth +                "px";            } else {              d.scrollbarH.style.display = "";              d.scrollbarH.firstChild.style.width = "0";            }            if (needsH && needsV) {              d.scrollbarFiller.style.display = "block";              d.scrollbarFiller.style.height = d.scrollbarFiller.style.width =                scrollbarWidth(d.measure) + "px";            } else d.scrollbarFiller.style.display = "";            if (              needsH &&              cm.options.coverGutterNextToScrollbar &&              cm.options.fixedGutter            ) {              d.gutterFiller.style.display = "block";              d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";              d.gutterFiller.style.width = d.gutters.offsetWidth + "px";            } else d.gutterFiller.style.display = "";            if (mac_geLion && scrollbarWidth(d.measure) === 0) {              d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight =                mac_geMountainLion ? "18px" : "12px";              d.scrollbarV.style.pointerEvents =                d.scrollbarH.style.pointerEvents = "none";            }          }          function visibleLines(display, doc, viewPort) {            var top = display.scroller.scrollTop,              height = display.wrapper.clientHeight;            if (typeof viewPort == "number") top = viewPort;            else if (viewPort) {              top = viewPort.top;              height = viewPort.bottom - viewPort.top;            }            top = Math.floor(top - paddingTop(display));            var bottom = Math.ceil(top + height);            return {              from: lineAtHeight(doc, top),              to: lineAtHeight(doc, bottom),            };          }          // LINE NUMBERS          function alignHorizontally(cm) {            var display = cm.display;            if (              !display.alignWidgets &&              (!display.gutters.firstChild || !cm.options.fixedGutter)            )              return;            var comp =              compensateForHScroll(display) -              display.scroller.scrollLeft +              cm.doc.scrollLeft;            var gutterW = display.gutters.offsetWidth,              l = comp + "px";            for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)              if (n.alignable) {                for (var i = 0, a = n.alignable; i < a.length; ++i)                  a[i].style.left = l;              }            if (cm.options.fixedGutter)              display.gutters.style.left = comp + gutterW + "px";          }          function maybeUpdateLineNumberWidth(cm) {            if (!cm.options.lineNumbers) return false;            var doc = cm.doc,              last = lineNumberFor(cm.options, doc.first + doc.size - 1),              display = cm.display;            if (last.length != display.lineNumChars) {              var test = display.measure.appendChild(                elt(                  "div",                  [elt("div", last)],                  "CodeMirror-linenumber CodeMirror-gutter-elt"                )              );              var innerW = test.firstChild.offsetWidth,                padding = test.offsetWidth - innerW;              display.lineGutter.style.width = "";              display.lineNumInnerWidth = Math.max(                innerW,                display.lineGutter.offsetWidth - padding              );              display.lineNumWidth = display.lineNumInnerWidth + padding;              display.lineNumChars = display.lineNumInnerWidth                ? last.length                : -1;              display.lineGutter.style.width = display.lineNumWidth + "px";              return true;            }            return false;          }          function lineNumberFor(options, i) {            return String(              options.lineNumberFormatter(i + options.firstLineNumber)            );          }          function compensateForHScroll(display) {            return getRect(display.scroller).left - getRect(display.sizer).left;          }          // DISPLAY DRAWING          function updateDisplay(cm, changes, viewPort, forced) {            var oldFrom = cm.display.showingFrom,              oldTo = cm.display.showingTo,              updated;            var visible = visibleLines(cm.display, cm.doc, viewPort);            for (var first = true; ; first = false) {              var oldWidth = cm.display.scroller.clientWidth;              if (!updateDisplayInner(cm, changes, visible, forced)) break;              updated = true;              changes = [];              updateSelection(cm);              updateScrollbars(cm);              if (                first &&                cm.options.lineWrapping &&                oldWidth != cm.display.scroller.clientWidth              ) {                forced = true;                continue;              }              forced = false;              // Clip forced viewport to actual scrollable area              if (viewPort)                viewPort = Math.min(                  cm.display.scroller.scrollHeight -                    cm.display.scroller.clientHeight,                  typeof viewPort == "number" ? viewPort : viewPort.top                );              visible = visibleLines(cm.display, cm.doc, viewPort);              if (                visible.from >= cm.display.showingFrom &&                visible.to <= cm.display.showingTo              )                break;            }            if (updated) {              signalLater(cm, "update", cm);              if (                cm.display.showingFrom != oldFrom ||                cm.display.showingTo != oldTo              )                signalLater(                  cm,                  "viewportChange",                  cm,                  cm.display.showingFrom,                  cm.display.showingTo                );            }            return updated;          }          // Uses a set of changes plus the current scroll position to          // determine which DOM updates have to be made, and makes the          // updates.          function updateDisplayInner(cm, changes, visible, forced) {            var display = cm.display,              doc = cm.doc;            if (!display.wrapper.offsetWidth) {              display.showingFrom = display.showingTo = doc.first;              display.viewOffset = 0;              return;            }            // Bail out if the visible area is already rendered and nothing changed.            if (              !forced &&              changes.length == 0 &&              visible.from > display.showingFrom &&              visible.to < display.showingTo            )              return;            if (maybeUpdateLineNumberWidth(cm))              changes = [{ from: doc.first, to: doc.first + doc.size }];            var gutterW = (display.sizer.style.marginLeft =              display.gutters.offsetWidth + "px");            display.scrollbarH.style.left = cm.options.fixedGutter              ? gutterW              : "0";            // Used to determine which lines need their line numbers updated            var positionsChangedFrom = Infinity;            if (cm.options.lineNumbers)              for (var i = 0; i < changes.length; ++i)                if (changes[i].diff && changes[i].from < positionsChangedFrom) {                  positionsChangedFrom = changes[i].from;                }            var end = doc.first + doc.size;            var from = Math.max(              visible.from - cm.options.viewportMargin,              doc.first            );            var to = Math.min(end, visible.to + cm.options.viewportMargin);            if (display.showingFrom < from && from - display.showingFrom < 20)              from = Math.max(doc.first, display.showingFrom);            if (display.showingTo > to && display.showingTo - to < 20)              to = Math.min(end, display.showingTo);            if (sawCollapsedSpans) {              from = lineNo(visualLine(doc, getLine(doc, from)));              while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;            }            // Create a range of theoretically intact lines, and punch holes            // in that using the change info.            var intact = [              {                from: Math.max(display.showingFrom, doc.first),                to: Math.min(display.showingTo, end),              },            ];            if (intact[0].from >= intact[0].to) intact = [];            else intact = computeIntact(intact, changes);            // When merged lines are present, we might have to reduce the            // intact ranges because changes in continued fragments of the            // intact lines do require the lines to be redrawn.            if (sawCollapsedSpans)              for (var i = 0; i < intact.length; ++i) {                var range = intact[i],                  merged;                while (                  (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1)))                ) {                  var newTo = merged.find().from.line;                  if (newTo > range.from) range.to = newTo;                  else {                    intact.splice(i--, 1);                    break;                  }                }              }            // Clip off the parts that won't be visible            var intactLines = 0;            for (var i = 0; i < intact.length; ++i) {              var range = intact[i];              if (range.from < from) range.from = from;              if (range.to > to) range.to = to;              if (range.from >= range.to) intact.splice(i--, 1);              else intactLines += range.to - range.from;            }            if (              !forced &&              intactLines == to - from &&              from == display.showingFrom &&              to == display.showingTo            ) {              updateViewOffset(cm);              return;            }            intact.sort(function (a, b) {              return a.from - b.from;            });            // Avoid crashing on IE's "unspecified error" when in iframes            try {              var focused = document.activeElement;            } catch (e) {}            if (intactLines < (to - from) * 0.7)              display.lineDiv.style.display = "none";            patchDisplay(cm, from, to, intact, positionsChangedFrom);            display.lineDiv.style.display = "";            if (              focused &&              document.activeElement != focused &&              focused.offsetHeight            )              focused.focus();            var different =              from != display.showingFrom ||              to != display.showingTo ||              display.lastSizeC != display.wrapper.clientHeight;            // This is just a bogus formula that detects when the editor is            // resized or the font size changes.            if (different) {              display.lastSizeC = display.wrapper.clientHeight;              startWorker(cm, 400);            }            display.showingFrom = from;            display.showingTo = to;            display.gutters.style.height = "";            updateHeightsInViewport(cm);            updateViewOffset(cm);            return true;          }          function updateHeightsInViewport(cm) {            var display = cm.display;            var prevBottom = display.lineDiv.offsetTop;            for (              var node = display.lineDiv.firstChild, height;              node;              node = node.nextSibling            )              if (node.lineObj) {                if (ie_lt8) {                  var bot = node.offsetTop + node.offsetHeight;                  height = bot - prevBottom;                  prevBottom = bot;                } else {                  var box = getRect(node);                  height = box.bottom - box.top;                }                var diff = node.lineObj.height - height;                if (height < 2) height = textHeight(display);                if (diff > 0.001 || diff < -0.001) {                  updateLineHeight(node.lineObj, height);                  var widgets = node.lineObj.widgets;                  if (widgets)                    for (var i = 0; i < widgets.length; ++i)                      widgets[i].height = widgets[i].node.offsetHeight;                }              }          }          function updateViewOffset(cm) {            var off = (cm.display.viewOffset = heightAtLine(              cm,              getLine(cm.doc, cm.display.showingFrom)            ));            // Position the mover div to align with the current virtual scroll position            cm.display.mover.style.top = off + "px";          }          function computeIntact(intact, changes) {            for (var i = 0, l = changes.length || 0; i < l; ++i) {              var change = changes[i],                intact2 = [],                diff = change.diff || 0;              for (var j = 0, l2 = intact.length; j < l2; ++j) {                var range = intact[j];                if (change.to <= range.from && change.diff) {                  intact2.push({                    from: range.from + diff,                    to: range.to + diff,                  });                } else if (change.to <= range.from || change.from >= range.to) {                  intact2.push(range);                } else {                  if (change.from > range.from)                    intact2.push({ from: range.from, to: change.from });                  if (change.to < range.to)                    intact2.push({                      from: change.to + diff,                      to: range.to + diff,                    });                }              }              intact = intact2;            }            return intact;          }          function getDimensions(cm) {            var d = cm.display,              left = {},              width = {};            for (              var n = d.gutters.firstChild, i = 0;              n;              n = n.nextSibling, ++i            ) {              left[cm.options.gutters[i]] = n.offsetLeft;              width[cm.options.gutters[i]] = n.offsetWidth;            }            return {              fixedPos: compensateForHScroll(d),              gutterTotalWidth: d.gutters.offsetWidth,              gutterLeft: left,              gutterWidth: width,              wrapperWidth: d.wrapper.clientWidth,            };          }          function patchDisplay(cm, from, to, intact, updateNumbersFrom) {            var dims = getDimensions(cm);            var display = cm.display,              lineNumbers = cm.options.lineNumbers;            if (!intact.length && (!webkit || !cm.display.currentWheelTarget))              removeChildren(display.lineDiv);            var container = display.lineDiv,              cur = container.firstChild;            function rm(node) {              var next = node.nextSibling;              if (webkit && mac && cm.display.currentWheelTarget == node) {                node.style.display = "none";                node.lineObj = null;              } else {                node.parentNode.removeChild(node);              }              return next;            }            var nextIntact = intact.shift(),              lineN = from;            cm.doc.iter(from, to, function (line) {              if (nextIntact && nextIntact.to == lineN)                nextIntact = intact.shift();              if (lineIsHidden(cm.doc, line)) {                if (line.height != 0) updateLineHeight(line, 0);                if (line.widgets && cur && cur.previousSibling)                  for (var i = 0; i < line.widgets.length; ++i) {                    var w = line.widgets[i];                    if (w.showIfHidden) {                      var prev = cur.previousSibling;                      if (/pre/i.test(prev.nodeName)) {                        var wrap = elt("div", null, null, "position: relative");                        prev.parentNode.replaceChild(wrap, prev);                        wrap.appendChild(prev);                        prev = wrap;                      }                      var wnode = prev.appendChild(                        elt("div", [w.node], "CodeMirror-linewidget")                      );                      if (!w.handleMouseEvents) wnode.ignoreEvents = true;                      positionLineWidget(w, wnode, prev, dims);                    }                  }              } else if (                nextIntact &&                nextIntact.from <= lineN &&                nextIntact.to > lineN              ) {                // This line is intact. Skip to the actual node. Update its                // line number if needed.                while (cur.lineObj != line) cur = rm(cur);                if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)                  setTextContent(                    cur.lineNumber,                    lineNumberFor(cm.options, lineN)                  );                cur = cur.nextSibling;              } else {                // For lines with widgets, make an attempt to find and reuse                // the existing element, so that widgets aren't needlessly                // removed and re-inserted into the dom                if (line.widgets)                  for (                    var j = 0, search = cur, reuse;                    search && j < 20;                    ++j, search = search.nextSibling                  )                    if (                      search.lineObj == line &&                      /div/i.test(search.nodeName)                    ) {                      reuse = search;                      break;                    }                // This line needs to be generated.                var lineNode = buildLineElement(cm, line, lineN, dims, reuse);                if (lineNode != reuse) {                  container.insertBefore(lineNode, cur);                } else {                  while (cur != reuse) cur = rm(cur);                  cur = cur.nextSibling;                }                lineNode.lineObj = line;              }              ++lineN;            });            while (cur) cur = rm(cur);          }          function buildLineElement(cm, line, lineNo, dims, reuse) {            var built = buildLineContent(cm, line),              lineElement = built.pre;            var markers = line.gutterMarkers,              display = cm.display,              wrap;            var bgClass = built.bgClass              ? built.bgClass + " " + (line.bgClass || "")              : line.bgClass;            if (              !cm.options.lineNumbers &&              !markers &&              !bgClass &&              !line.wrapClass &&              !line.widgets            )              return lineElement;            // Lines with gutter elements, widgets or a background class need            // to be wrapped again, and have the extra elements added to the            // wrapper div            if (reuse) {              reuse.alignable = null;              var isOk = true,                widgetsSeen = 0,                insertBefore = null;              for (var n = reuse.firstChild, next; n; n = next) {                next = n.nextSibling;                if (!/\bCodeMirror-linewidget\b/.test(n.className)) {                  reuse.removeChild(n);                } else {                  for (var i = 0; i < line.widgets.length; ++i) {                    var widget = line.widgets[i];                    if (widget.node == n.firstChild) {                      if (!widget.above && !insertBefore) insertBefore = n;                      positionLineWidget(widget, n, reuse, dims);                      ++widgetsSeen;                      break;                    }                  }                  if (i == line.widgets.length) {                    isOk = false;                    break;                  }                }              }              reuse.insertBefore(lineElement, insertBefore);              if (isOk && widgetsSeen == line.widgets.length) {                wrap = reuse;                reuse.className = line.wrapClass || "";              }            }            if (!wrap) {              wrap = elt("div", null, line.wrapClass, "position: relative");              wrap.appendChild(lineElement);            }            // Kludge to make sure the styled element lies behind the selection (by z-index)            if (bgClass)              wrap.insertBefore(                elt("div", null, bgClass + " CodeMirror-linebackground"),                wrap.firstChild              );            if (cm.options.lineNumbers || markers) {              var gutterWrap = wrap.insertBefore(                elt(                  "div",                  null,                  "CodeMirror-gutter-wrapper",                  "position: absolute; left: " +                    (cm.options.fixedGutter                      ? dims.fixedPos                      : -dims.gutterTotalWidth) +                    "px"                ),                lineElement              );              if (cm.options.fixedGutter)                (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);              if (                cm.options.lineNumbers &&                (!markers || !markers["CodeMirror-linenumbers"])              )                wrap.lineNumber = gutterWrap.appendChild(                  elt(                    "div",                    lineNumberFor(cm.options, lineNo),                    "CodeMirror-linenumber CodeMirror-gutter-elt",                    "left: " +                      dims.gutterLeft["CodeMirror-linenumbers"] +                      "px; width: " +                      display.lineNumInnerWidth +                      "px"                  )                );              if (markers)                for (var k = 0; k < cm.options.gutters.length; ++k) {                  var id = cm.options.gutters[k],                    found = markers.hasOwnProperty(id) && markers[id];                  if (found)                    gutterWrap.appendChild(                      elt(                        "div",                        [found],                        "CodeMirror-gutter-elt",                        "left: " +                          dims.gutterLeft[id] +                          "px; width: " +                          dims.gutterWidth[id] +                          "px"                      )                    );                }            }            if (ie_lt8) wrap.style.zIndex = 2;            if (line.widgets && wrap != reuse)              for (var i = 0, ws = line.widgets; i < ws.length; ++i) {                var widget = ws[i],                  node = elt("div", [widget.node], "CodeMirror-linewidget");                if (!widget.handleMouseEvents) node.ignoreEvents = true;                positionLineWidget(widget, node, wrap, dims);                if (widget.above)                  wrap.insertBefore(                    node,                    cm.options.lineNumbers && line.height != 0                      ? gutterWrap                      : lineElement                  );                else wrap.appendChild(node);                signalLater(widget, "redraw");              }            return wrap;          }          function positionLineWidget(widget, node, wrap, dims) {            if (widget.noHScroll) {              (wrap.alignable || (wrap.alignable = [])).push(node);              var width = dims.wrapperWidth;              node.style.left = dims.fixedPos + "px";              if (!widget.coverGutter) {                width -= dims.gutterTotalWidth;                node.style.paddingLeft = dims.gutterTotalWidth + "px";              }              node.style.width = width + "px";            }            if (widget.coverGutter) {              node.style.zIndex = 5;              node.style.position = "relative";              if (!widget.noHScroll)                node.style.marginLeft = -dims.gutterTotalWidth + "px";            }          }          // SELECTION / CURSOR          function updateSelection(cm) {            var display = cm.display;            var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);            if (collapsed || cm.options.showCursorWhenSelecting)              updateSelectionCursor(cm);            else              display.cursor.style.display = display.otherCursor.style.display =                "none";            if (!collapsed) updateSelectionRange(cm);            else display.selectionDiv.style.display = "none";            // Move the hidden textarea near the cursor to prevent scrolling artifacts            if (cm.options.moveInputWithCursor) {              var headPos = cursorCoords(cm, cm.doc.sel.head, "div");              var wrapOff = getRect(display.wrapper),                lineOff = getRect(display.lineDiv);              display.inputDiv.style.top =                Math.max(                  0,                  Math.min(                    display.wrapper.clientHeight - 10,                    headPos.top + lineOff.top - wrapOff.top                  )                ) + "px";              display.inputDiv.style.left =                Math.max(                  0,                  Math.min(                    display.wrapper.clientWidth - 10,                    headPos.left + lineOff.left - wrapOff.left                  )                ) + "px";            }          }          // No selection, plain cursor          function updateSelectionCursor(cm) {            var display = cm.display,              pos = cursorCoords(cm, cm.doc.sel.head, "div");            display.cursor.style.left = pos.left + "px";            display.cursor.style.top = pos.top + "px";            display.cursor.style.height =              Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight +              "px";            display.cursor.style.display = "";            if (pos.other) {              display.otherCursor.style.display = "";              display.otherCursor.style.left = pos.other.left + "px";              display.otherCursor.style.top = pos.other.top + "px";              display.otherCursor.style.height =                (pos.other.bottom - pos.other.top) * 0.85 + "px";            } else {              display.otherCursor.style.display = "none";            }          }          // Highlight selection          function updateSelectionRange(cm) {            var display = cm.display,              doc = cm.doc,              sel = cm.doc.sel;            var fragment = document.createDocumentFragment();            var padding = paddingH(cm.display),              leftSide = padding.left,              rightSide = display.lineSpace.offsetWidth - padding.right;            function add(left, top, width, bottom) {              if (top < 0) top = 0;              fragment.appendChild(                elt(                  "div",                  null,                  "CodeMirror-selected",                  "position: absolute; left: " +                    left +                    "px; top: " +                    top +                    "px; width: " +                    (width == null ? rightSide - left : width) +                    "px; height: " +                    (bottom - top) +                    "px"                )              );            }            function drawForLine(line, fromArg, toArg) {              var lineObj = getLine(doc, line);              var lineLen = lineObj.text.length;              var start, end;              function coords(ch, bias) {                return charCoords(cm, Pos(line, ch), "div", lineObj, bias);              }              iterateBidiSections(                getOrder(lineObj),                fromArg || 0,                toArg == null ? lineLen : toArg,                function (from, to, dir) {                  var leftPos = coords(from, "left"),                    rightPos,                    left,                    right;                  if (from == to) {                    rightPos = leftPos;                    left = right = leftPos.left;                  } else {                    rightPos = coords(to - 1, "right");                    if (dir == "rtl") {                      var tmp = leftPos;                      leftPos = rightPos;                      rightPos = tmp;                    }                    left = leftPos.left;                    right = rightPos.right;                  }                  if (fromArg == null && from == 0) left = leftSide;                  if (rightPos.top - leftPos.top > 3) {                    // Different lines, draw top part                    add(left, leftPos.top, null, leftPos.bottom);                    left = leftSide;                    if (leftPos.bottom < rightPos.top)                      add(left, leftPos.bottom, null, rightPos.top);                  }                  if (toArg == null && to == lineLen) right = rightSide;                  if (                    !start ||                    leftPos.top < start.top ||                    (leftPos.top == start.top && leftPos.left < start.left)                  )                    start = leftPos;                  if (                    !end ||                    rightPos.bottom > end.bottom ||                    (rightPos.bottom == end.bottom &&                      rightPos.right > end.right)                  )                    end = rightPos;                  if (left < leftSide + 1) left = leftSide;                  add(left, rightPos.top, right - left, rightPos.bottom);                }              );              return { start: start, end: end };            }            if (sel.from.line == sel.to.line) {              drawForLine(sel.from.line, sel.from.ch, sel.to.ch);            } else {              var fromLine = getLine(doc, sel.from.line),                toLine = getLine(doc, sel.to.line);              var singleVLine =                visualLine(doc, fromLine) == visualLine(doc, toLine);              var leftEnd = drawForLine(                sel.from.line,                sel.from.ch,                singleVLine ? fromLine.text.length : null              ).end;              var rightStart = drawForLine(                sel.to.line,                singleVLine ? 0 : null,                sel.to.ch              ).start;              if (singleVLine) {                if (leftEnd.top < rightStart.top - 2) {                  add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);                  add(                    leftSide,                    rightStart.top,                    rightStart.left,                    rightStart.bottom                  );                } else {                  add(                    leftEnd.right,                    leftEnd.top,                    rightStart.left - leftEnd.right,                    leftEnd.bottom                  );                }              }              if (leftEnd.bottom < rightStart.top)                add(leftSide, leftEnd.bottom, null, rightStart.top);            }            removeChildrenAndAdd(display.selectionDiv, fragment);            display.selectionDiv.style.display = "";          }          // Cursor-blinking          function restartBlink(cm) {            if (!cm.state.focused) return;            var display = cm.display;            clearInterval(display.blinker);            var on = true;            display.cursor.style.visibility =              display.otherCursor.style.visibility = "";            if (cm.options.cursorBlinkRate > 0)              display.blinker = setInterval(function () {                display.cursor.style.visibility =                  display.otherCursor.style.visibility = (on = !on)                    ? ""                    : "hidden";              }, cm.options.cursorBlinkRate);          }          // HIGHLIGHT WORKER          function startWorker(cm, time) {            if (              cm.doc.mode.startState &&              cm.doc.frontier < cm.display.showingTo            )              cm.state.highlight.set(time, bind(highlightWorker, cm));          }          function highlightWorker(cm) {            var doc = cm.doc;            if (doc.frontier < doc.first) doc.frontier = doc.first;            if (doc.frontier >= cm.display.showingTo) return;            var end = +new Date() + cm.options.workTime;            var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));            var changed = [],              prevChange;            doc.iter(              doc.frontier,              Math.min(doc.first + doc.size, cm.display.showingTo + 500),              function (line) {                if (doc.frontier >= cm.display.showingFrom) {                  // Visible                  var oldStyles = line.styles;                  line.styles = highlightLine(cm, line, state, true);                  var ischange =                    !oldStyles || oldStyles.length != line.styles.length;                  for (var i = 0; !ischange && i < oldStyles.length; ++i)                    ischange = oldStyles[i] != line.styles[i];                  if (ischange) {                    if (prevChange && prevChange.end == doc.frontier)                      prevChange.end++;                    else                      changed.push(                        (prevChange = {                          start: doc.frontier,                          end: doc.frontier + 1,                        })                      );                  }                  line.stateAfter = copyState(doc.mode, state);                } else {                  processLine(cm, line.text, state);                  line.stateAfter =                    doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;                }                ++doc.frontier;                if (+new Date() > end) {                  startWorker(cm, cm.options.workDelay);                  return true;                }              }            );            if (changed.length)              operation(cm, function () {                for (var i = 0; i < changed.length; ++i)                  regChange(this, changed[i].start, changed[i].end);              })();          }          // Finds the line to start with when starting a parse. Tries to          // find a line with a stateAfter, so that it can start with a          // valid state. If that fails, it returns the line with the          // smallest indentation, which tends to need the least context to          // parse correctly.          function findStartLine(cm, n, precise) {            var minindent,              minline,              doc = cm.doc;            var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);            for (var search = n; search > lim; --search) {              if (search <= doc.first) return doc.first;              var line = getLine(doc, search - 1);              if (line.stateAfter && (!precise || search <= doc.frontier))                return search;              var indented = countColumn(line.text, null, cm.options.tabSize);              if (minline == null || minindent > indented) {                minline = search - 1;                minindent = indented;              }            }            return minline;          }          function getStateBefore(cm, n, precise) {            var doc = cm.doc,              display = cm.display;            if (!doc.mode.startState) return true;            var pos = findStartLine(cm, n, precise),              state = pos > doc.first && getLine(doc, pos - 1).stateAfter;            if (!state) state = startState(doc.mode);            else state = copyState(doc.mode, state);            doc.iter(pos, n, function (line) {              processLine(cm, line.text, state);              var save =                pos == n - 1 ||                pos % 5 == 0 ||                (pos >= display.showingFrom && pos < display.showingTo);              line.stateAfter = save ? copyState(doc.mode, state) : null;              ++pos;            });            if (precise) doc.frontier = pos;            return state;          }          // POSITION MEASUREMENT          function paddingTop(display) {            return display.lineSpace.offsetTop;          }          function paddingVert(display) {            return display.mover.offsetHeight - display.lineSpace.offsetHeight;          }          function paddingH(display) {            if (display.cachedPaddingH) return display.cachedPaddingH;            var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));            var style = window.getComputedStyle              ? window.getComputedStyle(e)              : e.currentStyle;            return (display.cachedPaddingH = {              left: parseInt(style.paddingLeft),              right: parseInt(style.paddingRight),            });          }          function measureChar(cm, line, ch, data, bias) {            var dir = -1;            data = data || measureLine(cm, line);            if (data.crude) {              var left = data.left + ch * data.width;              return {                left: left,                right: left + data.width,                top: data.top,                bottom: data.bottom,              };            }            for (var pos = ch; ; pos += dir) {              var r = data[pos];              if (r) break;              if (dir < 0 && pos == 0) dir = 1;            }            bias = pos > ch ? "left" : pos < ch ? "right" : bias;            if (bias == "left" && r.leftSide) r = r.leftSide;            else if (bias == "right" && r.rightSide) r = r.rightSide;            return {              left: pos < ch ? r.right : r.left,              right: pos > ch ? r.left : r.right,              top: r.top,              bottom: r.bottom,            };          }          function findCachedMeasurement(cm, line) {            var cache = cm.display.measureLineCache;            for (var i = 0; i < cache.length; ++i) {              var memo = cache[i];              if (                memo.text == line.text &&                memo.markedSpans == line.markedSpans &&                cm.display.scroller.clientWidth == memo.width &&                memo.classes == line.textClass + "|" + line.wrapClass              )                return memo;            }          }          function clearCachedMeasurement(cm, line) {            var exists = findCachedMeasurement(cm, line);            if (exists)              exists.text = exists.measure = exists.markedSpans = null;          }          function measureLine(cm, line) {            // First look in the cache            var cached = findCachedMeasurement(cm, line);            if (cached) return cached.measure;            // Failing that, recompute and store result in cache            var measure = measureLineInner(cm, line);            var cache = cm.display.measureLineCache;            var memo = {              text: line.text,              width: cm.display.scroller.clientWidth,              markedSpans: line.markedSpans,              measure: measure,              classes: line.textClass + "|" + line.wrapClass,            };            if (cache.length == 16)              cache[++cm.display.measureLineCachePos % 16] = memo;            else cache.push(memo);            return measure;          }          function measureLineInner(cm, line) {            if (              !cm.options.lineWrapping &&              line.text.length >= cm.options.crudeMeasuringFrom            )              return crudelyMeasureLine(cm, line);            var display = cm.display,              measure = emptyArray(line.text.length);            var pre = buildLineContent(cm, line, measure, true).pre;            // IE does not cache element positions of inline elements between            // calls to getBoundingClientRect. This makes the loop below,            // which gathers the positions of all the characters on the line,            // do an amount of layout work quadratic to the number of            // characters. When line wrapping is off, we try to improve things            // by first subdividing the line into a bunch of inline blocks, so            // that IE can reuse most of the layout information from caches            // for those blocks. This does interfere with line wrapping, so it            // doesn't work when wrapping is on, but in that case the            // situation is slightly better, since IE does cache line-wrapping            // information and only recomputes per-line.            if (              old_ie &&              !ie_lt8 &&              !cm.options.lineWrapping &&              pre.childNodes.length > 100            ) {              var fragment = document.createDocumentFragment();              var chunk = 10,                n = pre.childNodes.length;              for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {                var wrap = elt("div", null, null, "display: inline-block");                for (var j = 0; j < chunk && n; ++j) {                  wrap.appendChild(pre.firstChild);                  --n;                }                fragment.appendChild(wrap);              }              pre.appendChild(fragment);            }            removeChildrenAndAdd(display.measure, pre);            var outer = getRect(display.lineDiv);            var vranges = [],              data = emptyArray(line.text.length),              maxBot = pre.offsetHeight;            // Work around an IE7/8 bug where it will sometimes have randomly            // replaced our pre with a clone at this point.            if (ie_lt9 && display.measure.first != pre)              removeChildrenAndAdd(display.measure, pre);            function measureRect(rect) {              var top = rect.top - outer.top,                bot = rect.bottom - outer.top;              if (bot > maxBot) bot = maxBot;              if (top < 0) top = 0;              for (var i = vranges.length - 2; i >= 0; i -= 2) {                var rtop = vranges[i],                  rbot = vranges[i + 1];                if (rtop > bot || rbot < top) continue;                if (                  (rtop <= top && rbot >= bot) ||                  (top <= rtop && bot >= rbot) ||                  Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1                ) {                  vranges[i] = Math.min(top, rtop);                  vranges[i + 1] = Math.max(bot, rbot);                  break;                }              }              if (i < 0) {                i = vranges.length;                vranges.push(top, bot);              }              return {                left: rect.left - outer.left,                right: rect.right - outer.left,                top: i,                bottom: null,              };            }            function finishRect(rect) {              rect.bottom = vranges[rect.top + 1];              rect.top = vranges[rect.top];            }            for (var i = 0, cur; i < measure.length; ++i)              if ((cur = measure[i])) {                var node = cur,                  rect = null;                // A widget might wrap, needs special care                if (                  /\bCodeMirror-widget\b/.test(cur.className) &&                  cur.getClientRects                ) {                  if (cur.firstChild.nodeType == 1) node = cur.firstChild;                  var rects = node.getClientRects();                  if (rects.length > 1) {                    rect = data[i] = measureRect(rects[0]);                    rect.rightSide = measureRect(rects[rects.length - 1]);                  }                }                if (!rect) rect = data[i] = measureRect(getRect(node));                if (cur.measureRight)                  rect.right = getRect(cur.measureRight).left - outer.left;                if (cur.leftSide)                  rect.leftSide = measureRect(getRect(cur.leftSide));              }            removeChildren(cm.display.measure);            for (var i = 0, cur; i < data.length; ++i)              if ((cur = data[i])) {                finishRect(cur);                if (cur.leftSide) finishRect(cur.leftSide);                if (cur.rightSide) finishRect(cur.rightSide);              }            return data;          }          function crudelyMeasureLine(cm, line) {            var copy = new Line(line.text.slice(0, 100), null);            if (line.textClass) copy.textClass = line.textClass;            var measure = measureLineInner(cm, copy);            var left = measureChar(cm, copy, 0, measure, "left");            var right = measureChar(cm, copy, 99, measure, "right");            return {              crude: true,              top: left.top,              left: left.left,              bottom: left.bottom,              width: (right.right - left.left) / 100,            };          }          function measureLineWidth(cm, line) {            var hasBadSpan = false;            if (line.markedSpans)              for (var i = 0; i < line.markedSpans; ++i) {                var sp = line.markedSpans[i];                if (                  sp.collapsed &&                  (sp.to == null || sp.to == line.text.length)                )                  hasBadSpan = true;              }            var cached = !hasBadSpan && findCachedMeasurement(cm, line);            if (cached || line.text.length >= cm.options.crudeMeasuringFrom)              return measureChar(                cm,                line,                line.text.length,                cached && cached.measure,                "right"              ).right;            var pre = buildLineContent(cm, line, null, true).pre;            var end = pre.appendChild(zeroWidthElement(cm.display.measure));            removeChildrenAndAdd(cm.display.measure, pre);            return getRect(end).right - getRect(cm.display.lineDiv).left;          }          function clearCaches(cm) {            cm.display.measureLineCache.length =              cm.display.measureLineCachePos = 0;            cm.display.cachedCharWidth =              cm.display.cachedTextHeight =              cm.display.cachedPaddingH =                null;            if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;            cm.display.lineNumChars = null;          }          function pageScrollX() {            return (              window.pageXOffset ||              (document.documentElement || document.body).scrollLeft            );          }          function pageScrollY() {            return (              window.pageYOffset ||              (document.documentElement || document.body).scrollTop            );          }          // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"          function intoCoordSystem(cm, lineObj, rect, context) {            if (lineObj.widgets)              for (var i = 0; i < lineObj.widgets.length; ++i)                if (lineObj.widgets[i].above) {                  var size = widgetHeight(lineObj.widgets[i]);                  rect.top += size;                  rect.bottom += size;                }            if (context == "line") return rect;            if (!context) context = "local";            var yOff = heightAtLine(cm, lineObj);            if (context == "local") yOff += paddingTop(cm.display);            else yOff -= cm.display.viewOffset;            if (context == "page" || context == "window") {              var lOff = getRect(cm.display.lineSpace);              yOff += lOff.top + (context == "window" ? 0 : pageScrollY());              var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());              rect.left += xOff;              rect.right += xOff;            }            rect.top += yOff;            rect.bottom += yOff;            return rect;          }          // Context may be "window", "page", "div", or "local"/null          // Result is in "div" coords          function fromCoordSystem(cm, coords, context) {            if (context == "div") return coords;            var left = coords.left,              top = coords.top;            // First move into "page" coordinate system            if (context == "page") {              left -= pageScrollX();              top -= pageScrollY();            } else if (context == "local" || !context) {              var localBox = getRect(cm.display.sizer);              left += localBox.left;              top += localBox.top;            }            var lineSpaceBox = getRect(cm.display.lineSpace);            return {              left: left - lineSpaceBox.left,              top: top - lineSpaceBox.top,            };          }          function charCoords(cm, pos, context, lineObj, bias) {            if (!lineObj) lineObj = getLine(cm.doc, pos.line);            return intoCoordSystem(              cm,              lineObj,              measureChar(cm, lineObj, pos.ch, null, bias),              context            );          }          function cursorCoords(cm, pos, context, lineObj, measurement) {            lineObj = lineObj || getLine(cm.doc, pos.line);            if (!measurement) measurement = measureLine(cm, lineObj);            function get(ch, right) {              var m = measureChar(                cm,                lineObj,                ch,                measurement,                right ? "right" : "left"              );              if (right) m.left = m.right;              else m.right = m.left;              return intoCoordSystem(cm, lineObj, m, context);            }            function getBidi(ch, partPos) {              var part = order[partPos],                right = part.level % 2;              if (                ch == bidiLeft(part) &&                partPos &&                part.level < order[partPos - 1].level              ) {                part = order[--partPos];                ch = bidiRight(part) - (part.level % 2 ? 0 : 1);                right = true;              } else if (                ch == bidiRight(part) &&                partPos < order.length - 1 &&                part.level < order[partPos + 1].level              ) {                part = order[++partPos];                ch = bidiLeft(part) - (part.level % 2);                right = false;              }              if (right && ch == part.to && ch > part.from) return get(ch - 1);              return get(ch, right);            }            var order = getOrder(lineObj),              ch = pos.ch;            if (!order) return get(ch);            var partPos = getBidiPartAt(order, ch);            var val = getBidi(ch, partPos);            if (bidiOther != null) val.other = getBidi(ch, bidiOther);            return val;          }          function PosWithInfo(line, ch, outside, xRel) {            var pos = new Pos(line, ch);            pos.xRel = xRel;            if (outside) pos.outside = true;            return pos;          }          // Coords must be lineSpace-local          function coordsChar(cm, x, y) {            var doc = cm.doc;            y += cm.display.viewOffset;            if (y < 0) return PosWithInfo(doc.first, 0, true, -1);            var lineNo = lineAtHeight(doc, y),              last = doc.first + doc.size - 1;            if (lineNo > last)              return PosWithInfo(                doc.first + doc.size - 1,                getLine(doc, last).text.length,                true,                1              );            if (x < 0) x = 0;            for (;;) {              var lineObj = getLine(doc, lineNo);              var found = coordsCharInner(cm, lineObj, lineNo, x, y);              var merged = collapsedSpanAtEnd(lineObj);              var mergedPos = merged && merged.find();              if (                merged &&                (found.ch > mergedPos.from.ch ||                  (found.ch == mergedPos.from.ch && found.xRel > 0))              )                lineNo = mergedPos.to.line;              else return found;            }          }          function coordsCharInner(cm, lineObj, lineNo, x, y) {            var innerOff = y - heightAtLine(cm, lineObj);            var wrongLine = false,              adjust = 2 * cm.display.wrapper.clientWidth;            var measurement = measureLine(cm, lineObj);            function getX(ch) {              var sp = cursorCoords(                cm,                Pos(lineNo, ch),                "line",                lineObj,                measurement              );              wrongLine = true;              if (innerOff > sp.bottom) return sp.left - adjust;              else if (innerOff < sp.top) return sp.left + adjust;              else wrongLine = false;              return sp.left;            }            var bidi = getOrder(lineObj),              dist = lineObj.text.length;            var from = lineLeft(lineObj),              to = lineRight(lineObj);            var fromX = getX(from),              fromOutside = wrongLine,              toX = getX(to),              toOutside = wrongLine;            if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);            // Do a binary search between these bounds.            for (;;) {              if (                bidi                  ? to == from || to == moveVisually(lineObj, from, 1)                  : to - from <= 1              ) {                var ch = x < fromX || x - fromX <= toX - x ? from : to;                var xDiff = x - (ch == from ? fromX : toX);                while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;                var pos = PosWithInfo(                  lineNo,                  ch,                  ch == from ? fromOutside : toOutside,                  xDiff < 0 ? -1 : xDiff ? 1 : 0                );                return pos;              }              var step = Math.ceil(dist / 2),                middle = from + step;              if (bidi) {                middle = from;                for (var i = 0; i < step; ++i)                  middle = moveVisually(lineObj, middle, 1);              }              var middleX = getX(middle);              if (middleX > x) {                to = middle;                toX = middleX;                if ((toOutside = wrongLine)) toX += 1000;                dist = step;              } else {                from = middle;                fromX = middleX;                fromOutside = wrongLine;                dist -= step;              }            }          }          var measureText;          function textHeight(display) {            if (display.cachedTextHeight != null)              return display.cachedTextHeight;            if (measureText == null) {              measureText = elt("pre");              // Measure a bunch of lines, for browsers that compute              // fractional heights.              for (var i = 0; i < 49; ++i) {                measureText.appendChild(document.createTextNode("x"));                measureText.appendChild(elt("br"));              }              measureText.appendChild(document.createTextNode("x"));            }            removeChildrenAndAdd(display.measure, measureText);            var height = measureText.offsetHeight / 50;            if (height > 3) display.cachedTextHeight = height;            removeChildren(display.measure);            return height || 1;          }          function charWidth(display) {            if (display.cachedCharWidth != null) return display.cachedCharWidth;            var anchor = elt("span", "x");            var pre = elt("pre", [anchor]);            removeChildrenAndAdd(display.measure, pre);            var width = anchor.offsetWidth;            if (width > 2) display.cachedCharWidth = width;            return width || 10;          }          // OPERATIONS          // Operations are used to wrap changes in such a way that each          // change won't have to update the cursor and display (which would          // be awkward, slow, and error-prone), but instead updates are          // batched and then all combined and executed at once.          var nextOpId = 0;          function startOperation(cm) {            cm.curOp = {              // An array of ranges of lines that have to be updated. See              // updateDisplay.              changes: [],              forceUpdate: false,              updateInput: null,              userSelChange: null,              textChanged: null,              selectionChanged: false,              cursorActivity: false,              updateMaxLine: false,              updateScrollPos: false,              id: ++nextOpId,            };            if (!delayedCallbackDepth++) delayedCallbacks = [];          }          function endOperation(cm) {            var op = cm.curOp,              doc = cm.doc,              display = cm.display;            cm.curOp = null;            if (op.updateMaxLine) computeMaxLength(cm);            if (              display.maxLineChanged &&              !cm.options.lineWrapping &&              display.maxLine            ) {              var width = measureLineWidth(cm, display.maxLine);              display.sizer.style.minWidth = Math.max(0, width + 3) + "px";              display.maxLineChanged = false;              var maxScrollLeft = Math.max(                0,                display.sizer.offsetLeft +                  display.sizer.offsetWidth -                  display.scroller.clientWidth              );              if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)                setScrollLeft(                  cm,                  Math.min(display.scroller.scrollLeft, maxScrollLeft),                  true                );            }            var newScrollPos, updated;            if (op.updateScrollPos) {              newScrollPos = op.updateScrollPos;            } else if (op.selectionChanged && display.scroller.clientHeight) {              // don't rescroll if not visible              var coords = cursorCoords(cm, doc.sel.head);              newScrollPos = calculateScrollPos(                cm,                coords.left,                coords.top,                coords.left,                coords.bottom              );            }            if (              op.changes.length ||              op.forceUpdate ||              (newScrollPos && newScrollPos.scrollTop != null)            ) {              updated = updateDisplay(                cm,                op.changes,                newScrollPos && newScrollPos.scrollTop,                op.forceUpdate              );              if (cm.display.scroller.offsetHeight)                cm.doc.scrollTop = cm.display.scroller.scrollTop;            }            if (!updated && op.selectionChanged) updateSelection(cm);            if (op.updateScrollPos) {              var top = Math.max(                0,                Math.min(                  display.scroller.scrollHeight - display.scroller.clientHeight,                  newScrollPos.scrollTop                )              );              var left = Math.max(                0,                Math.min(                  display.scroller.scrollWidth - display.scroller.clientWidth,                  newScrollPos.scrollLeft                )              );              display.scroller.scrollTop =                display.scrollbarV.scrollTop =                doc.scrollTop =                  top;              display.scroller.scrollLeft =                display.scrollbarH.scrollLeft =                doc.scrollLeft =                  left;              alignHorizontally(cm);              if (op.scrollToPos)                scrollPosIntoView(                  cm,                  clipPos(cm.doc, op.scrollToPos.from),                  clipPos(cm.doc, op.scrollToPos.to),                  op.scrollToPos.margin                );            } else if (newScrollPos) {              scrollCursorIntoView(cm);            }            if (op.selectionChanged) restartBlink(cm);            if (cm.state.focused && op.updateInput)              resetInput(cm, op.userSelChange);            var hidden = op.maybeHiddenMarkers,              unhidden = op.maybeUnhiddenMarkers;            if (hidden)              for (var i = 0; i < hidden.length; ++i)                if (!hidden[i].lines.length) signal(hidden[i], "hide");            if (unhidden)              for (var i = 0; i < unhidden.length; ++i)                if (unhidden[i].lines.length) signal(unhidden[i], "unhide");            var delayed;            if (!--delayedCallbackDepth) {              delayed = delayedCallbacks;              delayedCallbacks = null;            }            if (op.textChanged) signal(cm, "change", cm, op.textChanged);            if (op.cursorActivity) signal(cm, "cursorActivity", cm);            if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();          }          // Wraps a function in an operation. Returns the wrapped function.          function operation(cm1, f) {            return function () {              var cm = cm1 || this,                withOp = !cm.curOp;              if (withOp) startOperation(cm);              try {                var result = f.apply(cm, arguments);              } finally {                if (withOp) endOperation(cm);              }              return result;            };          }          function docOperation(f) {            return function () {              var withOp = this.cm && !this.cm.curOp,                result;              if (withOp) startOperation(this.cm);              try {                result = f.apply(this, arguments);              } finally {                if (withOp) endOperation(this.cm);              }              return result;            };          }          function runInOp(cm, f) {            var withOp = !cm.curOp,              result;            if (withOp) startOperation(cm);            try {              result = f();            } finally {              if (withOp) endOperation(cm);            }            return result;          }          function regChange(cm, from, to, lendiff) {            if (from == null) from = cm.doc.first;            if (to == null) to = cm.doc.first + cm.doc.size;            cm.curOp.changes.push({ from: from, to: to, diff: lendiff });          }          // INPUT HANDLING          function slowPoll(cm) {            if (cm.display.pollingFast) return;            cm.display.poll.set(cm.options.pollInterval, function () {              readInput(cm);              if (cm.state.focused) slowPoll(cm);            });          }          function fastPoll(cm) {            var missed = false;            cm.display.pollingFast = true;            function p() {              var changed = readInput(cm);              if (!changed && !missed) {                missed = true;                cm.display.poll.set(60, p);              } else {                cm.display.pollingFast = false;                slowPoll(cm);              }            }            cm.display.poll.set(20, p);          }          // prevInput is a hack to work with IME. If we reset the textarea          // on every change, that breaks IME. So we look for changes          // compared to the previous content instead. (Modern browsers have          // events that indicate IME taking place, but these are not widely          // supported or compatible enough yet to rely on.)          function readInput(cm) {            var input = cm.display.input,              prevInput = cm.display.prevInput,              doc = cm.doc,              sel = doc.sel;            if (              !cm.state.focused ||              hasSelection(input) ||              isReadOnly(cm) ||              cm.options.disableInput            )              return false;            if (cm.state.pasteIncoming && cm.state.fakedLastChar) {              input.value = input.value.substring(0, input.value.length - 1);              cm.state.fakedLastChar = false;            }            var text = input.value;            if (text == prevInput && posEq(sel.from, sel.to)) return false;            if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {              resetInput(cm, true);              return false;            }            var withOp = !cm.curOp;            if (withOp) startOperation(cm);            sel.shift = false;            var same = 0,              l = Math.min(prevInput.length, text.length);            while (              same < l &&              prevInput.charCodeAt(same) == text.charCodeAt(same)            )              ++same;            var from = sel.from,              to = sel.to;            var inserted = text.slice(same);            if (same < prevInput.length)              from = Pos(from.line, from.ch - (prevInput.length - same));            else if (              cm.state.overwrite &&              posEq(from, to) &&              !cm.state.pasteIncoming            )              to = Pos(                to.line,                Math.min(                  getLine(doc, to.line).text.length,                  to.ch + inserted.length                )              );            var updateInput = cm.curOp.updateInput;            var changeEvent = {              from: from,              to: to,              text: splitLines(inserted),              origin: cm.state.pasteIncoming                ? "paste"                : cm.state.cutIncoming                ? "cut"                : "+input",            };            makeChange(cm.doc, changeEvent, "end");            cm.curOp.updateInput = updateInput;            signalLater(cm, "inputRead", cm, changeEvent);            if (              inserted &&              !cm.state.pasteIncoming &&              cm.options.electricChars &&              cm.options.smartIndent &&              sel.head.ch < 100            ) {              var electric = cm.getModeAt(sel.head).electricChars;              if (electric)                for (var i = 0; i < electric.length; i++)                  if (inserted.indexOf(electric.charAt(i)) > -1) {                    indentLine(cm, sel.head.line, "smart");                    break;                  }            }            if (text.length > 1000 || text.indexOf("\n") > -1)              input.value = cm.display.prevInput = "";            else cm.display.prevInput = text;            if (withOp) endOperation(cm);            cm.state.pasteIncoming = cm.state.cutIncoming = false;            return true;          }          function resetInput(cm, user) {            var minimal,              selected,              doc = cm.doc;            if (!posEq(doc.sel.from, doc.sel.to)) {              cm.display.prevInput = "";              minimal =                hasCopyEvent &&                (doc.sel.to.line - doc.sel.from.line > 100 ||                  (selected = cm.getSelection()).length > 1000);              var content = minimal ? "-" : selected || cm.getSelection();              cm.display.input.value = content;              if (cm.state.focused) selectInput(cm.display.input);              if (ie && !ie_lt9) cm.display.inputHasSelection = content;            } else if (user) {              cm.display.prevInput = cm.display.input.value = "";              if (ie && !ie_lt9) cm.display.inputHasSelection = null;            }            cm.display.inaccurateSelection = minimal;          }          function focusInput(cm) {            if (              cm.options.readOnly != "nocursor" &&              (!mobile || document.activeElement != cm.display.input)            )              cm.display.input.focus();          }          function ensureFocus(cm) {            if (!cm.state.focused) {              focusInput(cm);              onFocus(cm);            }          }          function isReadOnly(cm) {            return cm.options.readOnly || cm.doc.cantEdit;          }          // EVENT HANDLERS          function registerEventHandlers(cm) {            var d = cm.display;            on(d.scroller, "mousedown", operation(cm, onMouseDown));            if (old_ie)              on(                d.scroller,                "dblclick",                operation(cm, function (e) {                  if (signalDOMEvent(cm, e)) return;                  var pos = posFromMouse(cm, e);                  if (                    !pos ||                    clickInGutter(cm, e) ||                    eventInWidget(cm.display, e)                  )                    return;                  e_preventDefault(e);                  var word = findWordAt(getLine(cm.doc, pos.line).text, pos);                  extendSelection(cm.doc, word.from, word.to);                })              );            else              on(d.scroller, "dblclick", function (e) {                signalDOMEvent(cm, e) || e_preventDefault(e);              });            on(d.lineSpace, "selectstart", function (e) {              if (!eventInWidget(d, e)) e_preventDefault(e);            });            // Gecko browsers fire contextmenu *after* opening the menu, at            // which point we can't mess with it anymore. Context menu is            // handled in onMouseDown for Gecko.            if (!captureMiddleClick)              on(d.scroller, "contextmenu", function (e) {                onContextMenu(cm, e);              });            on(d.scroller, "scroll", function () {              if (d.scroller.clientHeight) {                setScrollTop(cm, d.scroller.scrollTop);                setScrollLeft(cm, d.scroller.scrollLeft, true);                signal(cm, "scroll", cm);              }            });            on(d.scrollbarV, "scroll", function () {              if (d.scroller.clientHeight)                setScrollTop(cm, d.scrollbarV.scrollTop);            });            on(d.scrollbarH, "scroll", function () {              if (d.scroller.clientHeight)                setScrollLeft(cm, d.scrollbarH.scrollLeft);            });            on(d.scroller, "mousewheel", function (e) {              onScrollWheel(cm, e);            });            on(d.scroller, "DOMMouseScroll", function (e) {              onScrollWheel(cm, e);            });            function reFocus() {              if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);            }            on(d.scrollbarH, "mousedown", reFocus);            on(d.scrollbarV, "mousedown", reFocus);            // Prevent wrapper from ever scrolling            on(d.wrapper, "scroll", function () {              d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;            });            var resizeTimer;            function onResize() {              if (resizeTimer == null)                resizeTimer = setTimeout(function () {                  resizeTimer = null;                  // Might be a text scaling operation, clear size caches.                  d.cachedCharWidth =                    d.cachedTextHeight =                    d.cachedPaddingH =                    knownScrollbarWidth =                      null;                  clearCaches(cm);                  runInOp(cm, bind(regChange, cm));                }, 100);            }            on(window, "resize", onResize);            // Above handler holds on to the editor and its data structures.            // Here we poll to unregister it when the editor is no longer in            // the document, so that it can be garbage-collected.            function unregister() {              for (                var p = d.wrapper.parentNode;                p && p != document.body;                p = p.parentNode              ) {}              if (p) setTimeout(unregister, 5000);              else off(window, "resize", onResize);            }            setTimeout(unregister, 5000);            on(d.input, "keyup", operation(cm, onKeyUp));            on(d.input, "input", function () {              if (ie && !ie_lt9 && cm.display.inputHasSelection)                cm.display.inputHasSelection = null;              fastPoll(cm);            });            on(d.input, "keydown", operation(cm, onKeyDown));            on(d.input, "keypress", operation(cm, onKeyPress));            on(d.input, "focus", bind(onFocus, cm));            on(d.input, "blur", bind(onBlur, cm));            function drag_(e) {              if (                signalDOMEvent(cm, e) ||                (cm.options.onDragEvent &&                  cm.options.onDragEvent(cm, addStop(e)))              )                return;              e_stop(e);            }            if (cm.options.dragDrop) {              on(d.scroller, "dragstart", function (e) {                onDragStart(cm, e);              });              on(d.scroller, "dragenter", drag_);              on(d.scroller, "dragover", drag_);              on(d.scroller, "drop", operation(cm, onDrop));            }            on(d.scroller, "paste", function (e) {              if (eventInWidget(d, e)) return;              focusInput(cm);              fastPoll(cm);            });            on(d.input, "paste", function () {              // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206              // Add a char to the end of textarea before paste occur so that              // selection doesn't span to the end of textarea.              if (                webkit &&                !cm.state.fakedLastChar &&                !(new Date() - cm.state.lastMiddleDown < 200)              ) {                var start = d.input.selectionStart,                  end = d.input.selectionEnd;                d.input.value += "$";                d.input.selectionStart = start;                d.input.selectionEnd = end;                cm.state.fakedLastChar = true;              }              cm.state.pasteIncoming = true;              fastPoll(cm);            });            function prepareCopy(e) {              if (d.inaccurateSelection) {                d.prevInput = "";                d.inaccurateSelection = false;                d.input.value = cm.getSelection();                selectInput(d.input);              }              if (e.type == "cut") cm.state.cutIncoming = true;            }            on(d.input, "cut", prepareCopy);            on(d.input, "copy", prepareCopy);            // Needed to handle Tab key in KHTML            if (khtml)              on(d.sizer, "mouseup", function () {                if (document.activeElement == d.input) d.input.blur();                focusInput(cm);              });          }          function eventInWidget(display, e) {            for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {              if (                !n ||                n.ignoreEvents ||                (n.parentNode == display.sizer && n != display.mover)              )                return true;            }          }          function posFromMouse(cm, e, liberal) {            var display = cm.display;            if (!liberal) {              var target = e_target(e);              if (                target == display.scrollbarH ||                target == display.scrollbarH.firstChild ||                target == display.scrollbarV ||                target == display.scrollbarV.firstChild ||                target == display.scrollbarFiller ||                target == display.gutterFiller              )                return null;            }            var x,              y,              space = getRect(display.lineSpace);            // Fails unpredictably on IE[67] when mouse is dragged around quickly.            try {              x = e.clientX;              y = e.clientY;            } catch (e) {              return null;            }            return coordsChar(cm, x - space.left, y - space.top);          }          var lastClick, lastDoubleClick;          function onMouseDown(e) {            if (signalDOMEvent(this, e)) return;            var cm = this,              display = cm.display,              doc = cm.doc,              sel = doc.sel;            sel.shift = e.shiftKey;            if (eventInWidget(display, e)) {              if (!webkit) {                display.scroller.draggable = false;                setTimeout(function () {                  display.scroller.draggable = true;                }, 100);              }              return;            }            if (clickInGutter(cm, e)) return;            var start = posFromMouse(cm, e);            window.focus();            switch (e_button(e)) {              case 3:                if (captureMiddleClick) onContextMenu.call(cm, cm, e);                return;              case 2:                if (webkit) cm.state.lastMiddleDown = +new Date();                if (start) extendSelection(cm.doc, start);                setTimeout(bind(focusInput, cm), 20);                e_preventDefault(e);                return;            }            // For button 1, if it was clicked inside the editor            // (posFromMouse returning non-null), we have to adjust the            // selection.            if (!start) {              if (e_target(e) == display.scroller) e_preventDefault(e);              return;            }            setTimeout(bind(ensureFocus, cm), 0);            var now = +new Date(),              type = "single";            if (              lastDoubleClick &&              lastDoubleClick.time > now - 400 &&              posEq(lastDoubleClick.pos, start)            ) {              type = "triple";              e_preventDefault(e);              setTimeout(bind(focusInput, cm), 20);              selectLine(cm, start.line);            } else if (              lastClick &&              lastClick.time > now - 400 &&              posEq(lastClick.pos, start)            ) {              type = "double";              lastDoubleClick = { time: now, pos: start };              e_preventDefault(e);              var word = findWordAt(getLine(doc, start.line).text, start);              extendSelection(cm.doc, word.from, word.to);            } else {              lastClick = { time: now, pos: start };            }            var last = start;            if (              cm.options.dragDrop &&              dragAndDrop &&              !isReadOnly(cm) &&              !posEq(sel.from, sel.to) &&              !posLess(start, sel.from) &&              !posLess(sel.to, start) &&              type == "single"            ) {              var dragEnd = operation(cm, function (e2) {                if (webkit) display.scroller.draggable = false;                cm.state.draggingText = false;                off(document, "mouseup", dragEnd);                off(display.scroller, "drop", dragEnd);                if (                  Math.abs(e.clientX - e2.clientX) +                    Math.abs(e.clientY - e2.clientY) <                  10                ) {                  e_preventDefault(e2);                  extendSelection(cm.doc, start);                  focusInput(cm);                  // Work around unexplainable focus problem in IE9 (#2127)                  if (old_ie && !ie_lt9)                    setTimeout(function () {                      document.body.focus();                      focusInput(cm);                    }, 20);                }              });              // Let the drag handler handle this.              if (webkit) display.scroller.draggable = true;              cm.state.draggingText = dragEnd;              // IE's approach to draggable              if (display.scroller.dragDrop) display.scroller.dragDrop();              on(document, "mouseup", dragEnd);              on(display.scroller, "drop", dragEnd);              return;            }            e_preventDefault(e);            if (type == "single") extendSelection(cm.doc, clipPos(doc, start));            var startstart = sel.from,              startend = sel.to,              lastPos = start;            function doSelect(cur) {              if (posEq(lastPos, cur)) return;              lastPos = cur;              if (type == "single") {                extendSelection(cm.doc, clipPos(doc, start), cur);                return;              }              startstart = clipPos(doc, startstart);              startend = clipPos(doc, startend);              if (type == "double") {                var word = findWordAt(getLine(doc, cur.line).text, cur);                if (posLess(cur, startstart))                  extendSelection(cm.doc, word.from, startend);                else extendSelection(cm.doc, startstart, word.to);              } else if (type == "triple") {                if (posLess(cur, startstart))                  extendSelection(                    cm.doc,                    startend,                    clipPos(doc, Pos(cur.line, 0))                  );                else                  extendSelection(                    cm.doc,                    startstart,                    clipPos(doc, Pos(cur.line + 1, 0))                  );              }            }            var editorSize = getRect(display.wrapper);            // Used to ensure timeout re-tries don't fire when another extend            // happened in the meantime (clearTimeout isn't reliable -- at            // least on Chrome, the timeouts still happen even when cleared,            // if the clear happens after their scheduled firing time).            var counter = 0;            function extend(e) {              var curCount = ++counter;              var cur = posFromMouse(cm, e, true);              if (!cur) return;              if (!posEq(cur, last)) {                ensureFocus(cm);                last = cur;                doSelect(cur);                var visible = visibleLines(display, doc);                if (cur.line >= visible.to || cur.line < visible.from)                  setTimeout(                    operation(cm, function () {                      if (counter == curCount) extend(e);                    }),                    150                  );              } else {                var outside =                  e.clientY < editorSize.top                    ? -20                    : e.clientY > editorSize.bottom                    ? 20                    : 0;                if (outside)                  setTimeout(                    operation(cm, function () {                      if (counter != curCount) return;                      display.scroller.scrollTop += outside;                      extend(e);                    }),                    50                  );              }            }            function done(e) {              counter = Infinity;              e_preventDefault(e);              focusInput(cm);              off(document, "mousemove", move);              off(document, "mouseup", up);            }            var move = operation(cm, function (e) {              if (ie && !ie_lt10 ? !e.buttons : !e_button(e)) done(e);              else extend(e);            });            var up = operation(cm, done);            on(document, "mousemove", move);            on(document, "mouseup", up);          }          function gutterEvent(cm, e, type, prevent, signalfn) {            try {              var mX = e.clientX,                mY = e.clientY;            } catch (e) {              return false;            }            if (mX >= Math.floor(getRect(cm.display.gutters).right))              return false;            if (prevent) e_preventDefault(e);            var display = cm.display;            var lineBox = getRect(display.lineDiv);            if (mY > lineBox.bottom || !hasHandler(cm, type))              return e_defaultPrevented(e);            mY -= lineBox.top - display.viewOffset;            for (var i = 0; i < cm.options.gutters.length; ++i) {              var g = display.gutters.childNodes[i];              if (g && getRect(g).right >= mX) {                var line = lineAtHeight(cm.doc, mY);                var gutter = cm.options.gutters[i];                signalfn(cm, type, cm, line, gutter, e);                return e_defaultPrevented(e);              }            }          }          function contextMenuInGutter(cm, e) {            if (!hasHandler(cm, "gutterContextMenu")) return false;            return gutterEvent(cm, e, "gutterContextMenu", false, signal);          }          function clickInGutter(cm, e) {            return gutterEvent(cm, e, "gutterClick", true, signalLater);          }          // Kludge to work around strange IE behavior where it'll sometimes          // re-fire a series of drag-related events right after the drop (#1551)          var lastDrop = 0;          function onDrop(e) {            var cm = this;            if (              signalDOMEvent(cm, e) ||              eventInWidget(cm.display, e) ||              (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))            )              return;            e_preventDefault(e);            if (ie) lastDrop = +new Date();            var pos = posFromMouse(cm, e, true),              files = e.dataTransfer.files;            if (!pos || isReadOnly(cm)) return;            if (files && files.length && window.FileReader && window.File) {              var n = files.length,                text = Array(n),                read = 0;              var loadFile = function (file, i) {                var reader = new FileReader();                reader.onload = function () {                  text[i] = reader.result;                  if (++read == n) {                    pos = clipPos(cm.doc, pos);                    makeChange(                      cm.doc,                      {                        from: pos,                        to: pos,                        text: splitLines(text.join("\n")),                        origin: "paste",                      },                      "around"                    );                  }                };                reader.readAsText(file);              };              for (var i = 0; i < n; ++i) loadFile(files[i], i);            } else {              // Don't do a replace if the drop happened inside of the selected text.              if (                cm.state.draggingText &&                !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))              ) {                cm.state.draggingText(e);                // Ensure the editor is re-focused                setTimeout(bind(focusInput, cm), 20);                return;              }              try {                var text = e.dataTransfer.getData("Text");                if (text) {                  var curFrom = cm.doc.sel.from,                    curTo = cm.doc.sel.to;                  setSelection(cm.doc, pos, pos);                  if (cm.state.draggingText)                    replaceRange(cm.doc, "", curFrom, curTo, "paste");                  cm.replaceSelection(text, null, "paste");                  focusInput(cm);                }              } catch (e) {}            }          }          function onDragStart(cm, e) {            if (              ie &&              (!cm.state.draggingText || +new Date() - lastDrop < 100)            ) {              e_stop(e);              return;            }            if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;            var txt = cm.getSelection();            e.dataTransfer.setData("Text", txt);            // Use dummy image instead of default browsers image.            // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.            if (e.dataTransfer.setDragImage && !safari) {              var img = elt(                "img",                null,                null,                "position: fixed; left: 0; top: 0;"              );              img.src =                "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";              if (opera) {                img.width = img.height = 1;                cm.display.wrapper.appendChild(img);                // Force a relayout, or Opera won't use our image for some obscure reason                img._top = img.offsetTop;              }              e.dataTransfer.setDragImage(img, 0, 0);              if (opera) img.parentNode.removeChild(img);            }          }          function setScrollTop(cm, val) {            if (Math.abs(cm.doc.scrollTop - val) < 2) return;            cm.doc.scrollTop = val;            if (!gecko) updateDisplay(cm, [], val);            if (cm.display.scroller.scrollTop != val)              cm.display.scroller.scrollTop = val;            if (cm.display.scrollbarV.scrollTop != val)              cm.display.scrollbarV.scrollTop = val;            if (gecko) updateDisplay(cm, []);            startWorker(cm, 100);          }          function setScrollLeft(cm, val, isScroller) {            if (              isScroller                ? val == cm.doc.scrollLeft                : Math.abs(cm.doc.scrollLeft - val) < 2            )              return;            val = Math.min(              val,              cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth            );            cm.doc.scrollLeft = val;            alignHorizontally(cm);            if (cm.display.scroller.scrollLeft != val)              cm.display.scroller.scrollLeft = val;            if (cm.display.scrollbarH.scrollLeft != val)              cm.display.scrollbarH.scrollLeft = val;          }          // Since the delta values reported on mouse wheel events are          // unstandardized between browsers and even browser versions, and          // generally horribly unpredictable, this code starts by measuring          // the scroll effect that the first few mouse wheel events have,          // and, from that, detects the way it can convert deltas to pixel          // offsets afterwards.          //          // The reason we want to know the amount a wheel event will scroll          // is that it gives us a chance to update the display before the          // actual scrolling happens, reducing flickering.          var wheelSamples = 0,            wheelPixelsPerUnit = null;          // Fill in a browser-detected starting value on browsers where we          // know one. These don't have to be accurate -- the result of them          // being wrong would just be a slight flicker on the first wheel          // scroll (if it is large enough).          if (ie) wheelPixelsPerUnit = -0.53;          else if (gecko) wheelPixelsPerUnit = 15;          else if (chrome) wheelPixelsPerUnit = -0.7;          else if (safari) wheelPixelsPerUnit = -1 / 3;          function onScrollWheel(cm, e) {            var dx = e.wheelDeltaX,              dy = e.wheelDeltaY;            if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)              dx = e.detail;            if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)              dy = e.detail;            else if (dy == null) dy = e.wheelDelta;            var display = cm.display,              scroll = display.scroller;            // Quit if there's nothing to scroll here            if (              !(                (dx && scroll.scrollWidth > scroll.clientWidth) ||                (dy && scroll.scrollHeight > scroll.clientHeight)              )            )              return;            // Webkit browsers on OS X abort momentum scrolls when the target            // of the scroll event is removed from the scrollable element.            // This hack (see related code in patchDisplay) makes sure the            // element is kept around.            if (dy && mac && webkit) {              for (var cur = e.target; cur != scroll; cur = cur.parentNode) {                if (cur.lineObj) {                  cm.display.currentWheelTarget = cur;                  break;                }              }            }            // On some browsers, horizontal scrolling will cause redraws to            // happen before the gutter has been realigned, causing it to            // wriggle around in a most unseemly way. When we have an            // estimated pixels/delta value, we just handle horizontal            // scrolling entirely here. It'll be slightly off from native, but            // better than glitching out.            if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {              if (dy)                setScrollTop(                  cm,                  Math.max(                    0,                    Math.min(                      scroll.scrollTop + dy * wheelPixelsPerUnit,                      scroll.scrollHeight - scroll.clientHeight                    )                  )                );              setScrollLeft(                cm,                Math.max(                  0,                  Math.min(                    scroll.scrollLeft + dx * wheelPixelsPerUnit,                    scroll.scrollWidth - scroll.clientWidth                  )                )              );              e_preventDefault(e);              display.wheelStartX = null; // Abort measurement, if in progress              return;            }            if (dy && wheelPixelsPerUnit != null) {              var pixels = dy * wheelPixelsPerUnit;              var top = cm.doc.scrollTop,                bot = top + display.wrapper.clientHeight;              if (pixels < 0) top = Math.max(0, top + pixels - 50);              else bot = Math.min(cm.doc.height, bot + pixels + 50);              updateDisplay(cm, [], { top: top, bottom: bot });            }            if (wheelSamples < 20) {              if (display.wheelStartX == null) {                display.wheelStartX = scroll.scrollLeft;                display.wheelStartY = scroll.scrollTop;                display.wheelDX = dx;                display.wheelDY = dy;                setTimeout(function () {                  if (display.wheelStartX == null) return;                  var movedX = scroll.scrollLeft - display.wheelStartX;                  var movedY = scroll.scrollTop - display.wheelStartY;                  var sample =                    (movedY && display.wheelDY && movedY / display.wheelDY) ||                    (movedX && display.wheelDX && movedX / display.wheelDX);                  display.wheelStartX = display.wheelStartY = null;                  if (!sample) return;                  wheelPixelsPerUnit =                    (wheelPixelsPerUnit * wheelSamples + sample) /                    (wheelSamples + 1);                  ++wheelSamples;                }, 200);              } else {                display.wheelDX += dx;                display.wheelDY += dy;              }            }          }          function doHandleBinding(cm, bound, dropShift) {            if (typeof bound == "string") {              bound = commands[bound];              if (!bound) return false;            }            // Ensure previous input has been read, so that the handler sees a            // consistent view of the document            if (cm.display.pollingFast && readInput(cm))              cm.display.pollingFast = false;            var doc = cm.doc,              prevShift = doc.sel.shift,              done = false;            try {              if (isReadOnly(cm)) cm.state.suppressEdits = true;              if (dropShift) doc.sel.shift = false;              done = bound(cm) != Pass;            } finally {              doc.sel.shift = prevShift;              cm.state.suppressEdits = false;            }            return done;          }          function allKeyMaps(cm) {            var maps = cm.state.keyMaps.slice(0);            if (cm.options.extraKeys) maps.push(cm.options.extraKeys);            maps.push(cm.options.keyMap);            return maps;          }          var maybeTransition;          function handleKeyBinding(cm, e) {            // Handle auto keymap transitions            var startMap = getKeyMap(cm.options.keyMap),              next = startMap.auto;            clearTimeout(maybeTransition);            if (next && !isModifierKey(e))              maybeTransition = setTimeout(function () {                if (getKeyMap(cm.options.keyMap) == startMap) {                  cm.options.keyMap = next.call ? next.call(null, cm) : next;                  keyMapChanged(cm);                }              }, 50);            var name = keyName(e, true),              handled = false;            if (!name) return false;            var keymaps = allKeyMaps(cm);            if (e.shiftKey) {              // First try to resolve full name (including 'Shift-'). Failing              // that, see if there is a cursor-motion command (starting with              // 'go') bound to the keyname without 'Shift-'.              handled =                lookupKey("Shift-" + name, keymaps, function (b) {                  return doHandleBinding(cm, b, true);                }) ||                lookupKey(name, keymaps, function (b) {                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)                    return doHandleBinding(cm, b);                });            } else {              handled = lookupKey(name, keymaps, function (b) {                return doHandleBinding(cm, b);              });            }            if (handled) {              e_preventDefault(e);              restartBlink(cm);              if (ie_lt9) {                e.oldKeyCode = e.keyCode;                e.keyCode = 0;              }              signalLater(cm, "keyHandled", cm, name, e);            }            return handled;          }          function handleCharBinding(cm, e, ch) {            var handled = lookupKey(              "'" + ch + "'",              allKeyMaps(cm),              function (b) {                return doHandleBinding(cm, b, true);              }            );            if (handled) {              e_preventDefault(e);              restartBlink(cm);              signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);            }            return handled;          }          function onKeyUp(e) {            var cm = this;            if (              signalDOMEvent(cm, e) ||              (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))            )              return;            if (e.keyCode == 16) cm.doc.sel.shift = false;          }          var lastStoppedKey = null;          function onKeyDown(e) {            var cm = this;            ensureFocus(cm);            if (              signalDOMEvent(cm, e) ||              (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))            )              return;            if (old_ie && e.keyCode == 27) e.returnValue = false;            var code = e.keyCode;            // IE does strange things with escape.            cm.doc.sel.shift = code == 16 || e.shiftKey;            // First give onKeyEvent option a chance to handle this.            var handled = handleKeyBinding(cm, e);            if (opera) {              lastStoppedKey = handled ? code : null;              // Opera has no cut event... we try to at least catch the key combo              if (                !handled &&                code == 88 &&                !hasCopyEvent &&                (mac ? e.metaKey : e.ctrlKey)              )                cm.replaceSelection("");            }          }          function onKeyPress(e) {            var cm = this;            if (              signalDOMEvent(cm, e) ||              (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))            )              return;            var keyCode = e.keyCode,              charCode = e.charCode;            if (opera && keyCode == lastStoppedKey) {              lastStoppedKey = null;              e_preventDefault(e);              return;            }            if (              ((opera && (!e.which || e.which < 10)) || khtml) &&              handleKeyBinding(cm, e)            )              return;            var ch = String.fromCharCode(charCode == null ? keyCode : charCode);            if (handleCharBinding(cm, e, ch)) return;            if (ie && !ie_lt9) cm.display.inputHasSelection = null;            fastPoll(cm);          }          function onFocus(cm) {            if (cm.options.readOnly == "nocursor") return;            if (!cm.state.focused) {              signal(cm, "focus", cm);              cm.state.focused = true;              if (                cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) ==                -1              )                cm.display.wrapper.className += " CodeMirror-focused";              if (!cm.curOp) {                resetInput(cm, true);                if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730              }            }            slowPoll(cm);            restartBlink(cm);          }          function onBlur(cm) {            if (cm.state.focused) {              signal(cm, "blur", cm);              cm.state.focused = false;              cm.display.wrapper.className =                cm.display.wrapper.className.replace(" CodeMirror-focused", "");            }            clearInterval(cm.display.blinker);            setTimeout(function () {              if (!cm.state.focused) cm.doc.sel.shift = false;            }, 150);          }          var detectingSelectAll;          function onContextMenu(cm, e) {            if (signalDOMEvent(cm, e, "contextmenu")) return;            var display = cm.display,              sel = cm.doc.sel;            if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;            var pos = posFromMouse(cm, e),              scrollPos = display.scroller.scrollTop;            if (!pos || opera) return; // Opera is difficult.            // Reset the current text selection only if the click is done outside of the selection            // and 'resetSelectionOnContextMenu' option is true.            var reset = cm.options.resetSelectionOnContextMenu;            if (              reset &&              (posEq(sel.from, sel.to) ||                posLess(pos, sel.from) ||                !posLess(pos, sel.to))            )              operation(cm, setSelection)(cm.doc, pos, pos);            var oldCSS = display.input.style.cssText;            display.inputDiv.style.position = "absolute";            display.input.style.cssText =              "position: fixed; width: 30px; height: 30px; top: " +              (e.clientY - 5) +              "px; left: " +              (e.clientX - 5) +              "px; z-index: 1000; background: transparent; outline: none;" +              "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";            focusInput(cm);            resetInput(cm, true);            // Adds "Select all" to context menu in FF            if (posEq(sel.from, sel.to))              display.input.value = display.prevInput = " ";            function prepareSelectAllHack() {              if (display.input.selectionStart != null) {                var extval = (display.input.value =                  "\u200b" +                  (posEq(sel.from, sel.to) ? "" : display.input.value));                display.prevInput = "\u200b";                display.input.selectionStart = 1;                display.input.selectionEnd = extval.length;              }            }            function rehide() {              display.inputDiv.style.position = "relative";              display.input.style.cssText = oldCSS;              if (ie_lt9)                display.scrollbarV.scrollTop = display.scroller.scrollTop =             